<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Santorini</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
<style>
  :root {
    --stone-dark: #2c2416;
    --stone-mid: #5c4a2a;
    --stone-warm: #8b7355;
    --stone-light: #c4aa82;
    --stone-pale: #e8d9c0;
    --stone-white: #f5efe4;
    --marble-white: #f9f5ee;
    --marble-vein: #d4c4a8;
    --blue-deep: #1a3a5c;
    --blue-mid: #2e6da4;
    --blue-bright: #4fa3d4;
    --blue-sky: #87ceeb;
    --gold: #c9a84c;
    --gold-light: #e8c86a;
    --p1-color: #c0392b;
    --p1-light: #e74c3c;
    --p2-color: #1a5276;
    --p2-light: #2980b9;
    --shadow: rgba(0,0,0,0.4);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--stone-dark);
    font-family: 'Crimson Text', serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: hidden;
    background-image:
      radial-gradient(ellipse at 20% 20%, #3d2e1a 0%, transparent 50%),
      radial-gradient(ellipse at 80% 80%, #1a1208 0%, transparent 50%),
      url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
  }

  header {
    text-align: center;
    padding: 2rem 1rem 1rem;
    position: relative;
  }

  header h1 {
    font-family: 'Cinzel', serif;
    font-size: clamp(2.2rem, 6vw, 4rem);
    font-weight: 700;
    color: var(--stone-pale);
    letter-spacing: 0.25em;
    text-shadow: 0 2px 8px rgba(0,0,0,0.6), 0 0 30px rgba(201,168,76,0.3);
    position: relative;
  }

  header h1::after {
    content: '';
    display: block;
    width: 60%;
    height: 2px;
    margin: 0.5rem auto 0;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
  }

  header p {
    color: var(--stone-warm);
    font-style: italic;
    font-size: 1.1rem;
    margin-top: 0.4rem;
    letter-spacing: 0.05em;
  }

  .game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.5rem;
    padding: 1rem 1rem 2rem;
    width: 100%;
    max-width: 700px;
  }

  /* STATUS BAR */
  .status-bar {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
  }

  .player-panel {
    flex: 1;
    background: linear-gradient(135deg, #1e1810 0%, #2c2416 100%);
    border: 1px solid var(--stone-mid);
    border-radius: 8px;
    padding: 0.75rem 1rem;
    text-align: center;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }

  .player-panel::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, transparent 60%, rgba(255,255,255,0.03));
  }

  .player-panel.active-p1 {
    border-color: var(--p1-color);
    box-shadow: 0 0 20px rgba(192,57,43,0.3), inset 0 0 20px rgba(192,57,43,0.05);
  }

  .player-panel.active-p2 {
    border-color: var(--p2-color);
    box-shadow: 0 0 20px rgba(26,82,118,0.4), inset 0 0 20px rgba(26,82,118,0.05);
  }

  .player-name {
    font-family: 'Cinzel', serif;
    font-size: 0.85rem;
    letter-spacing: 0.15em;
    color: var(--stone-light);
    margin-bottom: 0.2rem;
  }

  .player-panel.active-p1 .player-name { color: var(--p1-light); }
  .player-panel.active-p2 .player-name { color: var(--blue-bright); }

  .worker-dots {
    display: flex;
    justify-content: center;
    gap: 6px;
    margin-top: 0.3rem;
  }

  .worker-dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    border: 2px solid currentColor;
    background: transparent;
    transition: all 0.2s;
  }

  .worker-dot.placed { background: currentColor; }
  .p1-dot { color: var(--p1-color); }
  .p2-dot { color: var(--p2-color); }

  .phase-display {
    flex: 1.2;
    text-align: center;
  }

  .phase-text {
    font-family: 'Cinzel', serif;
    font-size: clamp(0.75rem, 2vw, 0.95rem);
    color: var(--gold-light);
    letter-spacing: 0.1em;
    line-height: 1.4;
  }

  .phase-sub {
    font-size: 0.85rem;
    color: var(--stone-warm);
    font-style: italic;
    margin-top: 0.2rem;
  }

  /* BOARD */
  .board-wrapper {
    position: relative;
  }

  .board-shadow {
    position: absolute;
    inset: -12px;
    border-radius: 16px;
    background: transparent;
    box-shadow:
      0 20px 60px rgba(0,0,0,0.7),
      0 8px 20px rgba(0,0,0,0.5),
      inset 0 1px 0 rgba(255,255,255,0.05);
    pointer-events: none;
    z-index: -1;
  }

  .board {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(5, 1fr);
    gap: 4px;
    background: linear-gradient(145deg, #3a2e1c, #1e1810);
    padding: 10px;
    border-radius: 12px;
    border: 2px solid var(--stone-mid);
    width: min(92vw, 480px);
    height: min(92vw, 480px);
  }

  /* CELL */
  .cell {
    position: relative;
    border-radius: 6px;
    cursor: pointer;
    overflow: hidden;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .cell:hover { transform: scale(1.03); }

  /* Ground level (level 0) */
  .cell {
    background:
      linear-gradient(145deg, #c8b89a 0%, #a89070 40%, #8a7458 100%);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.25), inset 0 -2px 4px rgba(0,0,0,0.3);
  }

  /* Marble veining overlay */
  .cell::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image:
      repeating-linear-gradient(
        125deg,
        transparent 0px,
        transparent 8px,
        rgba(255,255,255,0.04) 8px,
        rgba(255,255,255,0.04) 9px,
        transparent 9px,
        transparent 18px
      );
    pointer-events: none;
    z-index: 1;
  }

  /* BUILDING LEVELS */
  .building {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
  }

  .level-1 .cell-bg {
    position: absolute;
    inset: 6%;
    background: linear-gradient(145deg, #e8ddd0, #c8bfb0, #a8a098);
    border-radius: 4px;
    box-shadow:
      0 4px 8px rgba(0,0,0,0.4),
      inset 0 1px 0 rgba(255,255,255,0.4),
      inset 0 -2px 4px rgba(0,0,0,0.2);
  }

  .level-2 .cell-bg {
    position: absolute;
    inset: 10%;
    background: linear-gradient(145deg, #f0ebe4, #d8d0c4, #b8b4aa);
    border-radius: 4px;
    box-shadow:
      0 6px 12px rgba(0,0,0,0.5),
      inset 0 1px 0 rgba(255,255,255,0.5),
      inset 0 -2px 6px rgba(0,0,0,0.2);
  }

  .level-3 .cell-bg {
    position: absolute;
    inset: 14%;
    background: linear-gradient(145deg, #f8f4ef, #e8e4dc, #ccc8c0);
    border-radius: 4px;
    box-shadow:
      0 8px 16px rgba(0,0,0,0.6),
      inset 0 1px 0 rgba(255,255,255,0.6),
      inset 0 -2px 8px rgba(0,0,0,0.15);
  }

  /* DOME */
  .dome-piece {
    position: absolute;
    width: 52%;
    height: 52%;
    border-radius: 50%;
    background: radial-gradient(circle at 35% 30%,
      #7ec8e3 0%,
      #4fa8d0 30%,
      #1e6fa8 60%,
      #0d3d6e 100%);
    box-shadow:
      0 4px 12px rgba(0,0,0,0.5),
      inset 0 -3px 6px rgba(0,0,0,0.3),
      inset 2px 2px 6px rgba(255,255,255,0.3);
    z-index: 3;
  }

  /* Level indicators */
  .level-badge {
    position: absolute;
    bottom: 3px;
    right: 4px;
    font-family: 'Cinzel', serif;
    font-size: 0.55rem;
    color: rgba(255,255,255,0.5);
    z-index: 4;
    pointer-events: none;
  }

  /* WORKERS */
  .worker {
    position: absolute;
    width: 44%;
    height: 44%;
    border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
    z-index: 5;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Cinzel', serif;
    font-size: 0.65rem;
    font-weight: 700;
    color: rgba(255,255,255,0.9);
    transition: transform 0.2s ease;
  }

  .worker-p1 {
    background: radial-gradient(circle at 40% 35%,
      #e74c3c 0%,
      #c0392b 50%,
      #922b21 100%);
    box-shadow:
      0 3px 8px rgba(0,0,0,0.5),
      inset 0 1px 3px rgba(255,255,255,0.3),
      0 0 0 2px rgba(192,57,43,0.5);
  }

  .worker-p2 {
    background: radial-gradient(circle at 40% 35%,
      #3498db 0%,
      #2980b9 50%,
      #1a5276 100%);
    box-shadow:
      0 3px 8px rgba(0,0,0,0.5),
      inset 0 1px 3px rgba(255,255,255,0.3),
      0 0 0 2px rgba(41,128,185,0.5);
  }

  .worker.selected-worker {
    transform: scale(1.2) translateY(-2px);
    box-shadow:
      0 6px 16px rgba(0,0,0,0.6),
      inset 0 1px 3px rgba(255,255,255,0.4),
      0 0 0 3px var(--gold),
      0 0 12px var(--gold);
  }

  /* HIGHLIGHTS */
  .cell.highlight-move {
    animation: pulse-move 1.2s ease-in-out infinite;
  }

  .cell.highlight-move::after {
    content: '';
    position: absolute;
    inset: 0;
    background: rgba(255, 220, 100, 0.2);
    border-radius: inherit;
    border: 2px solid rgba(255,220,100,0.7);
    z-index: 6;
    pointer-events: none;
  }

  .cell.highlight-build::after {
    content: '';
    position: absolute;
    inset: 0;
    background: rgba(100, 200, 120, 0.2);
    border-radius: inherit;
    border: 2px solid rgba(100,200,120,0.7);
    z-index: 6;
    pointer-events: none;
    animation: pulse-build 1.2s ease-in-out infinite;
  }

  .cell.highlight-place::after {
    content: '';
    position: absolute;
    inset: 0;
    background: rgba(200, 160, 255, 0.2);
    border-radius: inherit;
    border: 2px solid rgba(200,160,255,0.6);
    z-index: 6;
    pointer-events: none;
    animation: pulse-place 1.2s ease-in-out infinite;
  }

  @keyframes pulse-move {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.2); }
  }

  @keyframes pulse-build {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; }
  }

  @keyframes pulse-place {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
  }

  /* CONTROLS */
  .controls {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
    justify-content: center;
  }

  .btn {
    font-family: 'Cinzel', serif;
    font-size: 0.8rem;
    letter-spacing: 0.12em;
    padding: 0.6rem 1.4rem;
    border: 1px solid var(--stone-mid);
    border-radius: 4px;
    background: linear-gradient(135deg, #2c2416, #1e1810);
    color: var(--stone-light);
    cursor: pointer;
    transition: all 0.2s ease;
    text-transform: uppercase;
  }

  .btn:hover {
    border-color: var(--gold);
    color: var(--gold-light);
    box-shadow: 0 0 12px rgba(201,168,76,0.2);
  }

  .btn-primary {
    border-color: var(--gold);
    color: var(--gold-light);
    background: linear-gradient(135deg, #3a2e10, #2c2008);
  }

  .btn-primary:hover {
    background: linear-gradient(135deg, #4a3e18, #3a2c10);
    box-shadow: 0 0 16px rgba(201,168,76,0.3);
  }

  /* WIN OVERLAY */
  .overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    z-index: 100;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(4px);
  }

  .overlay.show { display: flex; }

  .win-card {
    background: linear-gradient(145deg, #2c2416, #1a1208);
    border: 2px solid var(--gold);
    border-radius: 16px;
    padding: 3rem 4rem;
    text-align: center;
    box-shadow:
      0 0 60px rgba(201,168,76,0.3),
      0 30px 60px rgba(0,0,0,0.8);
    animation: card-appear 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }

  @keyframes card-appear {
    from { transform: scale(0.7) translateY(20px); opacity: 0; }
    to { transform: scale(1) translateY(0); opacity: 1; }
  }

  .win-title {
    font-family: 'Cinzel', serif;
    font-size: 2.5rem;
    color: var(--gold-light);
    text-shadow: 0 0 30px rgba(201,168,76,0.5);
    margin-bottom: 0.5rem;
  }

  .win-subtitle {
    font-size: 1.3rem;
    color: var(--stone-pale);
    font-style: italic;
    margin-bottom: 2rem;
  }

  /* RULES */
  .rules-section {
    max-width: 460px;
    width: 100%;
    background: linear-gradient(135deg, #1e1810, #16120c);
    border: 1px solid var(--stone-mid);
    border-radius: 8px;
    padding: 1.2rem 1.5rem;
  }

  .rules-title {
    font-family: 'Cinzel', serif;
    font-size: 0.85rem;
    letter-spacing: 0.15em;
    color: var(--gold);
    margin-bottom: 0.75rem;
    text-transform: uppercase;
  }

  .rules-section p {
    color: var(--stone-warm);
    font-size: 0.95rem;
    line-height: 1.6;
    margin-bottom: 0.4rem;
  }

  .rules-section strong {
    color: var(--stone-light);
    font-weight: 600;
  }

  /* Responsive */
  @media (max-width: 500px) {
    .status-bar { flex-direction: column; gap: 0.5rem; }
    .player-panel, .phase-display { width: 100%; }
    .win-card { padding: 2rem; }
    .win-title { font-size: 1.8rem; }
  }
</style>
</head>
<body>

<header>
  <h1>SANTORINI</h1>
  <p>A game of divine construction</p>
</header>

<div class="game-container">

  <div class="status-bar">
    <div class="player-panel" id="panel-p1">
      <div class="player-name">PLAYER I</div>
      <div class="worker-dots">
        <div class="worker-dot p1-dot" id="dot-p1-0"></div>
        <div class="worker-dot p1-dot" id="dot-p1-1"></div>
      </div>
    </div>
    <div class="phase-display">
      <div class="phase-text" id="phase-text">PLACE WORKERS</div>
      <div class="phase-sub" id="phase-sub">Player I places first</div>
    </div>
    <div class="player-panel" id="panel-p2">
      <div class="player-name">PLAYER II</div>
      <div class="worker-dots">
        <div class="worker-dot p2-dot" id="dot-p2-0"></div>
        <div class="worker-dot p2-dot" id="dot-p2-1"></div>
      </div>
    </div>
  </div>

  <div class="board-wrapper">
    <div class="board-shadow"></div>
    <div class="board" id="board"></div>
  </div>

  <div class="controls">
    <button class="btn btn-primary" onclick="newGame()">NEW GAME</button>
    <button class="btn" id="btn-cancel" onclick="cancelSelection()" style="display:none">CANCEL</button>
  </div>

  <div class="rules-section">
    <div class="rules-title">How to Play</div>
    <p><strong>Setup:</strong> Each player places 2 workers on the board.</p>
    <p><strong>Turn:</strong> Move one worker to an adjacent space (including diagonals), then build a level on any adjacent space.</p>
    <p><strong>Win:</strong> Move a worker onto a <strong>level-3 tower</strong> to win. You may only climb 1 level per move.</p>
    <p><strong>Blocked:</strong> If a player cannot move, they lose.</p>
  </div>

</div>

<div class="overlay" id="win-overlay">
  <div class="win-card">
    <div class="win-title" id="win-title">VICTORY</div>
    <div class="win-subtitle" id="win-subtitle">Player I has ascended!</div>
    <button class="btn btn-primary" style="margin-top:1rem" onclick="newGame()">PLAY AGAIN</button>
  </div>
</div>

<script>
// ─── GAME STATE ───────────────────────────────────────────────────────────────
const BOARD_SIZE = 5;

let state = {};

function initState() {
  return {
    board: Array.from({length: BOARD_SIZE}, () =>
      Array.from({length: BOARD_SIZE}, () => ({ level: 0, dome: false, worker: null }))
    ),
    workers: {
      p1: [null, null], // {r, c} or null
      p2: [null, null],
    },
    phase: 'place',      // place | select | move | build
    currentPlayer: 'p1',
    placedCount: { p1: 0, p2: 0 },
    selectedWorker: null, // index 0 or 1
    highlightCells: [],
  };
}

// ─── HELPERS ──────────────────────────────────────────────────────────────────
function neighbors(r, c) {
  const res = [];
  for (let dr = -1; dr <= 1; dr++)
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue;
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE)
        res.push([nr, nc]);
    }
  return res;
}

function cellOccupied(r, c) {
  return state.board[r][c].worker !== null;
}

function getWorkerCell(player, idx) {
  return state.workers[player][idx]; // {r, c} or null
}

function validMoves(player, idx) {
  const w = state.workers[player][idx];
  if (!w) return [];
  const fromLevel = state.board[w.r][w.c].level;
  return neighbors(w.r, w.c).filter(([nr, nc]) => {
    const cell = state.board[nr][nc];
    return !cell.dome && !cellOccupied(nr, nc) && cell.level <= fromLevel + 1;
  });
}

function validBuilds(r, c) {
  return neighbors(r, c).filter(([nr, nc]) => {
    const cell = state.board[nr][nc];
    return !cell.dome && !cellOccupied(nr, nc);
  });
}

function canPlayerMove(player) {
  return state.workers[player].some((_, i) => validMoves(player, i).length > 0);
}

function opponent(player) { return player === 'p1' ? 'p2' : 'p1'; }

// ─── RENDER ───────────────────────────────────────────────────────────────────
function render() {
  const board = document.getElementById('board');
  board.innerHTML = '';

  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      const cell = state.board[r][c];
      const div = document.createElement('div');
      div.className = 'cell';
      div.dataset.r = r;
      div.dataset.c = c;

      // Building layers
      if (cell.level > 0) {
        div.classList.add(`level-${cell.level}`);
        const bg = document.createElement('div');
        bg.className = 'cell-bg';
        div.appendChild(bg);
      }

      // Dome
      if (cell.dome) {
        const dome = document.createElement('div');
        dome.className = 'dome-piece';
        div.appendChild(dome);
      }

      // Level badge
      if (cell.level > 0 && !cell.dome) {
        const badge = document.createElement('div');
        badge.className = 'level-badge';
        badge.textContent = cell.level;
        div.appendChild(badge);
      }

      // Worker
      if (cell.worker) {
        const w = document.createElement('div');
        w.className = `worker worker-${cell.worker.player}`;
        const isSelected = state.phase !== 'place' &&
          state.selectedWorker !== null &&
          state.workers[state.currentPlayer][state.selectedWorker]?.r === r &&
          state.workers[state.currentPlayer][state.selectedWorker]?.c === c;
        if (isSelected) w.classList.add('selected-worker');
        w.textContent = cell.worker.idx === 0 ? 'A' : 'B';
        div.appendChild(w);
      }

      // Highlights
      const h = state.highlightCells.find(([hr, hc]) => hr === r && hc === c);
      if (h) div.classList.add(h[2]);

      div.addEventListener('click', () => onCellClick(r, c));
      board.appendChild(div);
    }
  }

  // Update panels
  const p1Active = state.currentPlayer === 'p1';
  document.getElementById('panel-p1').className = 'player-panel' + (p1Active ? ' active-p1' : '');
  document.getElementById('panel-p2').className = 'player-panel' + (!p1Active ? ' active-p2' : '');

  // Worker dots
  ['p1','p2'].forEach(p => {
    [0,1].forEach(i => {
      const dot = document.getElementById(`dot-${p}-${i}`);
      dot.classList.toggle('placed', state.workers[p][i] !== null);
    });
  });

  // Phase text
  const phaseEl = document.getElementById('phase-text');
  const subEl = document.getElementById('phase-sub');
  const pName = state.currentPlayer === 'p1' ? 'Player I' : 'Player II';

  if (state.phase === 'place') {
    phaseEl.textContent = 'PLACE WORKERS';
    subEl.textContent = `${pName} — click an empty space`;
  } else if (state.phase === 'select') {
    phaseEl.textContent = 'SELECT WORKER';
    subEl.textContent = `${pName} — choose a worker`;
  } else if (state.phase === 'move') {
    phaseEl.textContent = 'MOVE';
    subEl.textContent = `${pName} — choose a space`;
  } else if (state.phase === 'build') {
    phaseEl.textContent = 'BUILD';
    subEl.textContent = `${pName} — choose where to build`;
  }

  // Cancel button
  document.getElementById('btn-cancel').style.display =
    (state.phase === 'move') ? 'inline-block' : 'none';
}

// ─── INTERACTION ──────────────────────────────────────────────────────────────
function onCellClick(r, c) {
  const cell = state.board[r][c];

  if (state.phase === 'place') {
    if (cell.worker || cell.dome) return;
    const p = state.currentPlayer;
    const idx = state.placedCount[p];
    cell.worker = { player: p, idx };
    state.workers[p][idx] = { r, c };
    state.placedCount[p]++;

    // Advance placement turn
    const totalPlaced = state.placedCount.p1 + state.placedCount.p2;
    if (totalPlaced < 4) {
      // Alternate: p1, p2, p2, p1 (each places 2)
      if (totalPlaced === 1) state.currentPlayer = 'p2';
      else if (totalPlaced === 2) state.currentPlayer = 'p2';
      else if (totalPlaced === 3) state.currentPlayer = 'p1';
    } else {
      state.phase = 'select';
      state.currentPlayer = 'p1';
      state.highlightCells = [];
    }
    render();
    return;
  }

  if (state.phase === 'select') {
    // Click on own worker
    const p = state.currentPlayer;
    const workerIdx = state.workers[p].findIndex(w => w && w.r === r && w.c === c);
    if (workerIdx !== -1) {
      const moves = validMoves(p, workerIdx);
      if (moves.length === 0) return; // can't move this worker
      state.selectedWorker = workerIdx;
      state.phase = 'move';
      state.highlightCells = moves.map(([mr, mc]) => [mr, mc, 'highlight-move']);
      render();
    }
    return;
  }

  if (state.phase === 'move') {
    const isHighlighted = state.highlightCells.find(([hr, hc]) => hr === r && hc === c);
    if (!isHighlighted) {
      // Maybe clicked own other worker to switch selection
      const p = state.currentPlayer;
      const workerIdx = state.workers[p].findIndex(w => w && w.r === r && w.c === c);
      if (workerIdx !== -1 && workerIdx !== state.selectedWorker) {
        const moves = validMoves(p, workerIdx);
        if (moves.length === 0) return;
        state.selectedWorker = workerIdx;
        state.highlightCells = moves.map(([mr, mc]) => [mr, mc, 'highlight-move']);
        render();
      }
      return;
    }

    // Execute move
    const p = state.currentPlayer;
    const idx = state.selectedWorker;
    const oldW = state.workers[p][idx];
    state.board[oldW.r][oldW.c].worker = null;
    state.board[r][c].worker = { player: p, idx };
    state.workers[p][idx] = { r, c };

    // Check win: moved to level 3
    if (state.board[r][c].level === 3) {
      render();
      showWin(p);
      return;
    }

    // Build phase
    const builds = validBuilds(r, c);
    state.phase = 'build';
    state.highlightCells = builds.map(([br, bc]) => [br, bc, 'highlight-build']);
    render();
    return;
  }

  if (state.phase === 'build') {
    const isHighlighted = state.highlightCells.find(([hr, hc]) => hr === r && hc === c);
    if (!isHighlighted) return;

    const cell2 = state.board[r][c];
    if (cell2.level < 3) {
      cell2.level++;
    } else {
      cell2.dome = true;
    }

    // Switch player
    const nextPlayer = opponent(state.currentPlayer);
    if (!canPlayerMove(nextPlayer)) {
      render();
      showWin(state.currentPlayer);
      return;
    }

    state.currentPlayer = nextPlayer;
    state.selectedWorker = null;
    state.phase = 'select';
    state.highlightCells = [];
    render();
    return;
  }
}

function cancelSelection() {
  if (state.phase === 'move') {
    state.phase = 'select';
    state.selectedWorker = null;
    state.highlightCells = [];
    render();
  }
}

function showWin(player) {
  const overlay = document.getElementById('win-overlay');
  const title = document.getElementById('win-title');
  const sub = document.getElementById('win-subtitle');
  title.textContent = 'VICTORY';
  sub.textContent = `${player === 'p1' ? 'Player I' : 'Player II'} has ascended to glory!`;
  overlay.classList.add('show');
}

function newGame() {
  document.getElementById('win-overlay').classList.remove('show');
  state = initState();
  render();
}

// ─── INIT ─────────────────────────────────────────────────────────────────────
state = initState();
render();
</script>
</body>
</html>
