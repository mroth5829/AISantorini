<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Santorini</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GLOBAL RESET & SHARED
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --gold: #c9a84c;
  --gold-light: #e8c86a;
  --stone-dark: #2c2416;
  --stone-mid: #5c4a2a;
  --stone-warm: #8b7355;
  --stone-light: #c4aa82;
  --stone-pale: #e8d9c0;
  --p1: #c0392b;
  --p1l: #e74c3c;
  --p2: #1a5276;
  --p2l: #2980b9;
}

html, body {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* â”€â”€ SCREENS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.screen { display: none; width: 100%; flex-direction: column; align-items: center; }
.screen.active { display: flex; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MENU SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#screen-menu {
  min-height: 100vh;
  justify-content: center;
  background: #12100a;
  background-image:
    radial-gradient(ellipse at 30% 20%, #2a1e0e 0%, transparent 55%),
    radial-gradient(ellipse at 70% 80%, #0e1020 0%, transparent 55%),
    url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23n)' opacity='0.07'/%3E%3C/svg%3E");
}

.menu-inner {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 3rem;
  padding: 3rem 1.5rem;
  max-width: 680px;
  width: 100%;
}

.menu-title-wrap { text-align: center; }

.menu-title {
  font-family: 'Cinzel', serif;
  font-size: clamp(2.8rem, 8vw, 5rem);
  font-weight: 700;
  color: var(--stone-pale);
  letter-spacing: 0.3em;
  text-shadow: 0 2px 12px rgba(0,0,0,0.8), 0 0 40px rgba(201,168,76,0.35);
  line-height: 1;
}

.menu-title-rule {
  width: 50%;
  height: 2px;
  margin: 1rem auto 0;
  background: linear-gradient(90deg, transparent, var(--gold), transparent);
}

.menu-subtitle {
  font-family: 'Crimson Text', serif;
  color: var(--stone-warm);
  font-style: italic;
  font-size: 1.2rem;
  margin-top: 0.6rem;
  letter-spacing: 0.08em;
}

.menu-cards {
  display: flex;
  gap: 1.5rem;
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
}

.mode-card {
  flex: 1;
  min-width: 240px;
  max-width: 300px;
  background: linear-gradient(145deg, #1e1a10, #141008);
  border: 2px solid var(--stone-mid);
  border-radius: 12px;
  padding: 2rem 1.5rem;
  cursor: pointer;
  transition: transform 0.25s ease, border-color 0.25s ease, box-shadow 0.25s ease;
  position: relative;
  overflow: hidden;
  text-align: center;
}

.mode-card::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(255,255,255,0.03) 0%, transparent 60%);
  pointer-events: none;
}

.mode-card:hover {
  transform: translateY(-6px);
  border-color: var(--gold);
  box-shadow: 0 16px 48px rgba(0,0,0,0.6), 0 0 30px rgba(201,168,76,0.2);
}

.mode-card:active { transform: translateY(-2px); }

.card-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
  display: block;
  filter: drop-shadow(0 4px 8px rgba(0,0,0,0.5));
}

.card-title {
  font-family: 'Cinzel', serif;
  font-size: 1rem;
  letter-spacing: 0.2em;
  color: var(--stone-pale);
  margin-bottom: 0.5rem;
}

.card-tag {
  display: inline-block;
  font-family: 'Cinzel', serif;
  font-size: 0.55rem;
  letter-spacing: 0.15em;
  padding: 0.2rem 0.6rem;
  border: 1px solid var(--gold);
  color: var(--gold);
  border-radius: 2px;
  margin-bottom: 1rem;
}

.card-desc {
  font-family: 'Crimson Text', serif;
  font-size: 0.95rem;
  color: var(--stone-warm);
  line-height: 1.6;
}

.card-cta {
  display: block;
  margin-top: 1.5rem;
  font-family: 'Cinzel', serif;
  font-size: 0.7rem;
  letter-spacing: 0.15em;
  color: var(--gold-light);
  text-transform: uppercase;
  transition: letter-spacing 0.2s;
}

.mode-card:hover .card-cta { letter-spacing: 0.25em; }

.menu-rules {
  max-width: 500px;
  width: 100%;
  background: linear-gradient(135deg, #1a160e, #12100a);
  border: 1px solid #3a2e18;
  border-radius: 8px;
  padding: 1.2rem 1.5rem;
}

.rules-heading {
  font-family: 'Cinzel', serif;
  font-size: 0.7rem;
  letter-spacing: 0.2em;
  color: var(--gold);
  margin-bottom: 0.8rem;
  text-transform: uppercase;
}

.menu-rules p {
  font-family: 'Crimson Text', serif;
  color: var(--stone-warm);
  font-size: 0.95rem;
  line-height: 1.65;
  margin-bottom: 0.35rem;
}

.menu-rules strong { color: var(--stone-light); }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MARBLE GAME SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#screen-marble {
  min-height: 100vh;
  background: var(--stone-dark);
  background-image:
    radial-gradient(ellipse at 20% 20%, #3d2e1a 0%, transparent 50%),
    radial-gradient(ellipse at 80% 80%, #1a1208 0%, transparent 50%),
    url("data:image/svg+xml,%3Csvg width='200' height='200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
  font-family: 'Crimson Text', serif;
  overflow-x: hidden;
}

/* â”€â”€ Marble Header â”€â”€ */
.m-header {
  text-align: center;
  padding: 1.5rem 1rem 0.5rem;
  width: 100%;
}

.m-header h1 {
  font-family: 'Cinzel', serif;
  font-size: clamp(1.8rem, 5vw, 3rem);
  font-weight: 700;
  color: var(--stone-pale);
  letter-spacing: 0.25em;
  text-shadow: 0 2px 8px rgba(0,0,0,0.6), 0 0 30px rgba(201,168,76,0.3);
}

.m-header h1::after {
  content: '';
  display: block;
  width: 60%;
  height: 2px;
  margin: 0.4rem auto 0;
  background: linear-gradient(90deg, transparent, var(--gold), transparent);
}

.m-back-btn {
  font-family: 'Cinzel', serif;
  font-size: 0.6rem;
  letter-spacing: 0.12em;
  color: var(--stone-warm);
  background: none;
  border: none;
  cursor: pointer;
  padding: 0.3rem 0;
  margin-top: 0.3rem;
  transition: color 0.2s;
  display: block;
  margin-left: auto;
  margin-right: auto;
}
.m-back-btn:hover { color: var(--gold-light); }

/* â”€â”€ Marble Game Container â”€â”€ */
.m-game {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.2rem;
  padding: 0.5rem 1rem 2rem;
  width: 100%;
  max-width: 680px;
}

.m-status-bar {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
}

.m-player-panel {
  flex: 1;
  background: linear-gradient(135deg, #1e1810, #2c2416);
  border: 1px solid var(--stone-mid);
  border-radius: 8px;
  padding: 0.65rem 1rem;
  text-align: center;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.m-player-panel::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, transparent 60%, rgba(255,255,255,0.03));
}

.m-player-panel.active-p1 { border-color: var(--p1); box-shadow: 0 0 20px rgba(192,57,43,0.3), inset 0 0 20px rgba(192,57,43,0.05); }
.m-player-panel.active-p2 { border-color: var(--p2); box-shadow: 0 0 20px rgba(26,82,118,0.4), inset 0 0 20px rgba(26,82,118,0.05); }

.m-player-name {
  font-family: 'Cinzel', serif;
  font-size: 0.8rem;
  letter-spacing: 0.15em;
  color: var(--stone-light);
  margin-bottom: 0.2rem;
}

.m-player-panel.active-p1 .m-player-name { color: var(--p1l); }
.m-player-panel.active-p2 .m-player-name { color: #4fa3d4; }

.m-worker-dots { display: flex; justify-content: center; gap: 6px; margin-top: 0.3rem; }

.m-dot {
  width: 13px; height: 13px;
  border-radius: 50%;
  border: 2px solid currentColor;
  background: transparent;
  transition: all 0.2s;
}
.m-dot.placed { background: currentColor; }
.m-dot.p1c { color: var(--p1); }
.m-dot.p2c { color: var(--p2); }

.m-phase-display { flex: 1.2; text-align: center; }

.m-phase-text {
  font-family: 'Cinzel', serif;
  font-size: clamp(0.65rem, 1.8vw, 0.85rem);
  color: var(--gold-light);
  letter-spacing: 0.1em;
  line-height: 1.4;
}

.m-phase-sub {
  font-size: 0.82rem;
  color: var(--stone-warm);
  font-style: italic;
  margin-top: 0.2rem;
}

/* â”€â”€ Marble Board â”€â”€ */
.m-board-wrapper { position: relative; }

.m-board-shadow {
  position: absolute; inset: -12px;
  border-radius: 16px;
  background: transparent;
  box-shadow: 0 20px 60px rgba(0,0,0,0.7), 0 8px 20px rgba(0,0,0,0.5);
  pointer-events: none; z-index: -1;
}

.m-board {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: repeat(5, 1fr);
  gap: 4px;
  background: linear-gradient(145deg, #3a2e1c, #1e1810);
  padding: 10px;
  border-radius: 12px;
  border: 2px solid var(--stone-mid);
  width: min(88vw, 460px);
  height: min(88vw, 460px);
}

.m-cell {
  position: relative;
  border-radius: 6px;
  cursor: pointer;
  overflow: hidden;
  transition: transform 0.15s ease;
  display: flex; align-items: center; justify-content: center;
  background: linear-gradient(145deg, #c8b89a 0%, #a89070 40%, #8a7458 100%);
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.25), inset 0 -2px 4px rgba(0,0,0,0.3);
}

.m-cell:hover { transform: scale(1.04); }

.m-cell::before {
  content: '';
  position: absolute; inset: 0;
  background-image: repeating-linear-gradient(125deg, transparent 0px, transparent 8px, rgba(255,255,255,0.04) 8px, rgba(255,255,255,0.04) 9px, transparent 9px, transparent 18px);
  pointer-events: none; z-index: 1;
}

.m-cell-bg {
  position: absolute;
  border-radius: 4px;
}

.m-cell.lv1 .m-cell-bg { inset: 6%; background: linear-gradient(145deg, #e8ddd0, #c8bfb0, #a8a098); box-shadow: 0 4px 8px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.4); }
.m-cell.lv2 .m-cell-bg { inset: 10%; background: linear-gradient(145deg, #f0ebe4, #d8d0c4, #b8b4aa); box-shadow: 0 6px 12px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.5); }
.m-cell.lv3 .m-cell-bg { inset: 14%; background: linear-gradient(145deg, #f8f4ef, #e8e4dc, #ccc8c0); box-shadow: 0 8px 16px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.6); }

.m-dome-piece {
  position: absolute;
  width: 52%; height: 52%;
  border-radius: 50%;
  background: radial-gradient(circle at 35% 30%, #7ec8e3 0%, #4fa8d0 30%, #1e6fa8 60%, #0d3d6e 100%);
  box-shadow: 0 4px 12px rgba(0,0,0,0.5), inset 0 -3px 6px rgba(0,0,0,0.3), inset 2px 2px 6px rgba(255,255,255,0.3);
  z-index: 3;
}

.m-lv-badge {
  position: absolute; bottom: 3px; right: 4px;
  font-family: 'Cinzel', serif; font-size: 0.5rem;
  color: rgba(255,255,255,0.5); z-index: 4; pointer-events: none;
}

.m-worker {
  position: absolute;
  width: 44%; height: 44%;
  border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
  z-index: 5;
  display: flex; align-items: center; justify-content: center;
  font-family: 'Cinzel', serif; font-size: 0.6rem; font-weight: 700;
  color: rgba(255,255,255,0.9);
  transition: transform 0.2s ease;
}

.m-worker.wp1 {
  background: radial-gradient(circle at 40% 35%, #e74c3c 0%, #c0392b 50%, #922b21 100%);
  box-shadow: 0 3px 8px rgba(0,0,0,0.5), inset 0 1px 3px rgba(255,255,255,0.3), 0 0 0 2px rgba(192,57,43,0.5);
}

.m-worker.wp2 {
  background: radial-gradient(circle at 40% 35%, #3498db 0%, #2980b9 50%, #1a5276 100%);
  box-shadow: 0 3px 8px rgba(0,0,0,0.5), inset 0 1px 3px rgba(255,255,255,0.3), 0 0 0 2px rgba(41,128,185,0.5);
}

.m-worker.sel-w {
  transform: scale(1.22) translateY(-2px);
  box-shadow: 0 6px 16px rgba(0,0,0,0.6), inset 0 1px 3px rgba(255,255,255,0.4), 0 0 0 3px var(--gold), 0 0 12px var(--gold);
}

.m-cell.hl-move  { animation: pulse-m 1.2s ease-in-out infinite; }
.m-cell.hl-move::after  { content:''; position:absolute; inset:0; background:rgba(255,220,100,0.2); border-radius:inherit; border:2px solid rgba(255,220,100,0.7); z-index:6; pointer-events:none; }
.m-cell.hl-build::after { content:''; position:absolute; inset:0; background:rgba(100,200,120,0.2); border-radius:inherit; border:2px solid rgba(100,200,120,0.7); z-index:6; pointer-events:none; animation:pulse-b 1.2s ease-in-out infinite; }
.m-cell.hl-place::after { content:''; position:absolute; inset:0; background:rgba(200,160,255,0.2); border-radius:inherit; border:2px solid rgba(200,160,255,0.6); z-index:6; pointer-events:none; animation:pulse-p 1.2s ease-in-out infinite; }

@keyframes pulse-m { 0%,100%{filter:brightness(1)} 50%{filter:brightness(1.2)} }
@keyframes pulse-b { 0%,100%{opacity:.8} 50%{opacity:1} }
@keyframes pulse-p { 0%,100%{opacity:.7} 50%{opacity:1} }

/* â”€â”€ Marble Controls â”€â”€ */
.m-controls { display: flex; gap: 0.75rem; flex-wrap: wrap; justify-content: center; }

.m-btn {
  font-family: 'Cinzel', serif;
  font-size: 0.72rem;
  letter-spacing: 0.12em;
  padding: 0.55rem 1.3rem;
  border: 1px solid var(--stone-mid);
  border-radius: 4px;
  background: linear-gradient(135deg, #2c2416, #1e1810);
  color: var(--stone-light);
  cursor: pointer;
  transition: all 0.2s ease;
  text-transform: uppercase;
}

.m-btn:hover { border-color: var(--gold); color: var(--gold-light); box-shadow: 0 0 12px rgba(201,168,76,0.2); }
.m-btn-primary { border-color: var(--gold); color: var(--gold-light); background: linear-gradient(135deg, #3a2e10, #2c2008); }
.m-btn-primary:hover { background: linear-gradient(135deg, #4a3e18, #3a2c10); }

/* â”€â”€ Marble Win Overlay â”€â”€ */
.m-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.8); z-index:100; align-items:center; justify-content:center; backdrop-filter:blur(4px); }
.m-overlay.show { display:flex; }

.m-win-card {
  background: linear-gradient(145deg, #2c2416, #1a1208);
  border: 2px solid var(--gold);
  border-radius: 16px;
  padding: 2.5rem 3.5rem;
  text-align: center;
  box-shadow: 0 0 60px rgba(201,168,76,0.3), 0 30px 60px rgba(0,0,0,0.8);
  animation: card-pop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

@keyframes card-pop { from{transform:scale(0.7) translateY(20px);opacity:0} to{transform:scale(1) translateY(0);opacity:1} }

.m-win-title { font-family:'Cinzel',serif; font-size:2.2rem; color:var(--gold-light); text-shadow:0 0 30px rgba(201,168,76,0.5); margin-bottom:0.5rem; }
.m-win-sub { font-size:1.2rem; color:var(--stone-pale); font-style:italic; margin-bottom:1.8rem; font-family:'Crimson Text',serif; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ISO GAME SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#screen-iso {
  min-height: 100vh;
  background: #0a0a1a;
  background-image:
    radial-gradient(ellipse at 50% 0%, #1a1040 0%, transparent 60%),
    repeating-linear-gradient(0deg, transparent, transparent 31px, rgba(255,255,255,0.015) 31px, rgba(255,255,255,0.015) 32px),
    repeating-linear-gradient(90deg, transparent, transparent 31px, rgba(255,255,255,0.015) 31px, rgba(255,255,255,0.015) 32px);
  font-family: 'Press Start 2P', monospace;
}

.iso-header { text-align: center; padding: 1.5rem 1rem 0.3rem; width: 100%; }

.iso-header h1 {
  font-family: 'Press Start 2P', monospace;
  font-size: clamp(0.9rem, 3vw, 1.5rem);
  color: #f8e860;
  text-shadow: 3px 3px 0 #b8880a, 6px 6px 0 rgba(0,0,0,0.5);
  letter-spacing: 0.15em;
}

.iso-back-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 0.38rem;
  color: #555588;
  background: none;
  border: none;
  cursor: pointer;
  padding: 0.3rem 0;
  margin-top: 0.4rem;
  letter-spacing: 0.08em;
  transition: color 0.2s;
  display: block;
  margin-left: auto;
  margin-right: auto;
}
.iso-back-btn:hover { color: #f8e860; }

.iso-wrap {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.7rem;
  padding: 0.5rem 0.8rem 1.5rem;
  width: 100%;
  max-width: 760px;
}

.iso-status-bar { display: flex; align-items: stretch; gap: 0.5rem; width: 100%; }

.iso-player-panel {
  flex: 1;
  background: #0e0e2a;
  border: 3px solid #333366;
  padding: 0.5rem 0.6rem;
  position: relative;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.iso-player-panel::before { content:''; position:absolute; inset:2px; border:1px solid rgba(255,255,255,0.05); pointer-events:none; }
.iso-player-panel.active-p1 { border-color:#e84040; box-shadow:0 0 16px rgba(232,64,64,0.4), inset 0 0 16px rgba(232,64,64,0.05); }
.iso-player-panel.active-p2 { border-color:#4080e8; box-shadow:0 0 16px rgba(64,128,232,0.4), inset 0 0 16px rgba(64,128,232,0.05); }

.iso-player-label { font-size: 0.4rem; letter-spacing: 0.1em; color: #888; margin-bottom: 0.3rem; }
.iso-player-panel.active-p1 .iso-player-label { color: #ff8888; }
.iso-player-panel.active-p2 .iso-player-label { color: #88aaff; }

.iso-pips { display: flex; gap: 4px; margin-top: 0.2rem; }
.iso-pip { width: 8px; height: 8px; border: 2px solid currentColor; }
.iso-pip.filled { background: currentColor; }
.iso-pip.p1c { color: #e84040; }
.iso-pip.p2c { color: #4080e8; }

.iso-phase-box {
  flex: 1.3;
  background: #0e0e2a;
  border: 3px solid #333366;
  padding: 0.5rem;
  text-align: center;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
}

.iso-phase-main { font-size: clamp(0.35rem, 1vw, 0.48rem); color: #f8e860; letter-spacing: 0.08em; }
.iso-phase-hint { font-size: clamp(0.28rem, 0.85vw, 0.38rem); color: #7070aa; margin-top: 0.4rem; letter-spacing: 0.05em; line-height: 1.6; }

.iso-canvas-wrap { position: relative; cursor: crosshair; }

canvas#iso-c { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }

.iso-controls { display: flex; gap: 0.6rem; }

.iso-btn {
  font-family: 'Press Start 2P', monospace;
  font-size: 0.42rem;
  letter-spacing: 0.08em;
  padding: 0.5rem 1rem;
  background: #0e0e2a;
  border: 3px solid #444488;
  color: #aaaacc;
  cursor: pointer;
  transition: all 0.1s;
}

.iso-btn:hover { border-color: #f8e860; color: #f8e860; box-shadow: 0 0 10px rgba(248,232,96,0.3); }
.iso-btn:active { transform: translate(1px,1px); }
.iso-btn-primary { border-color: #f8e860; color: #f8e860; }

.iso-legend { display:flex; gap:0.8rem; flex-wrap:wrap; justify-content:center; padding:0.4rem; font-size:0.32rem; color:#555588; letter-spacing:0.05em; }
.iso-legend span { display:flex; align-items:center; gap:3px; }
.iso-ldot { width:7px; height:7px; display:inline-block; border:1px solid rgba(255,255,255,0.2); }

.iso-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,8,0.88); z-index:50; align-items:center; justify-content:center; }
.iso-overlay.show { display:flex; }

.iso-win-box {
  background: #0e0e2a;
  border: 4px solid #f8e860;
  padding: 2.5rem 3rem;
  text-align: center;
  box-shadow: 0 0 40px rgba(248,232,96,0.4), 8px 8px 0 rgba(0,0,0,0.8);
  animation: iso-pop 0.3s cubic-bezier(.17,.67,.35,1.4);
}

@keyframes iso-pop { from{transform:scale(0.5);opacity:0} to{transform:scale(1);opacity:1} }

.iso-win-title { font-size: clamp(0.75rem, 3vw, 1.1rem); color: #f8e860; text-shadow: 4px 4px 0 #b8880a; margin-bottom: 0.8rem; }
.iso-win-sub { font-size: clamp(0.38rem, 1.3vw, 0.52rem); color: #aaaacc; margin-bottom: 1.5rem; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GREEK 32-BIT SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
#screen-greek {
  min-height: 100vh;
  background: #1a120a;
  background-image:
    radial-gradient(ellipse at 40% 10%, #2e1e08 0%, transparent 50%),
    radial-gradient(ellipse at 60% 90%, #0a1818 0%, transparent 50%),
    radial-gradient(ellipse at 90% 40%, #1a0e04 0%, transparent 40%);
  font-family: 'Cinzel', serif;
}

.gk-header { text-align: center; padding: 1.2rem 1rem 0.3rem; width: 100%; }

.gk-header h1 {
  font-family: 'Cinzel', serif;
  font-size: clamp(1.6rem, 4.5vw, 2.8rem);
  font-weight: 700;
  color: #f0e8d0;
  letter-spacing: 0.2em;
  text-shadow: 0 2px 10px rgba(0,0,0,0.8), 0 0 30px rgba(106,171,154,0.3);
}

.gk-header h1::after {
  content: '';
  display: block;
  width: 55%;
  height: 1px;
  margin: 0.4rem auto 0;
  background: linear-gradient(90deg, transparent, #6aab9a, transparent);
}

.gk-back-btn {
  font-family: 'Cinzel', serif;
  font-size: 0.58rem;
  letter-spacing: 0.1em;
  color: #4a7a6a;
  background: none; border: none; cursor: pointer;
  padding: 0.3rem 0; margin-top: 0.2rem;
  transition: color 0.2s;
  display: block; margin-left: auto; margin-right: auto;
}
.gk-back-btn:hover { color: #8fcfbf; }

.gk-wrap {
  display: flex; flex-direction: column; align-items: center;
  gap: 0.8rem; padding: 0.3rem 0.8rem 1.5rem;
  width: 100%; max-width: 860px;
}

.gk-status-bar { display: flex; align-items: stretch; gap: 0.6rem; width: 100%; }

.gk-player-panel {
  flex: 1;
  background: linear-gradient(135deg, #1e1608, #150f04);
  border: 2px solid #3a3020;
  border-radius: 6px;
  padding: 0.5rem 0.8rem;
  position: relative;
  transition: border-color 0.25s, box-shadow 0.25s;
}
.gk-player-panel.active-p1 { border-color:#c04030; box-shadow:0 0 18px rgba(192,64,48,0.35); }
.gk-player-panel.active-p2 { border-color:#3060c0; box-shadow:0 0 18px rgba(48,96,192,0.35); }

.gk-player-label { font-family:'Cinzel',serif; font-size:0.55rem; letter-spacing:0.15em; color:#7a6a48; margin-bottom:0.25rem; }
.gk-player-panel.active-p1 .gk-player-label { color:#e07060; }
.gk-player-panel.active-p2 .gk-player-label { color:#6090e0; }

.gk-pips { display:flex; gap:5px; margin-top:0.2rem; }
.gk-pip { width:10px; height:10px; border-radius:50%; border:2px solid currentColor; transition:all 0.2s; }
.gk-pip.filled { background:currentColor; }
.gk-pip.p1c { color:#c04030; }
.gk-pip.p2c { color:#3060c0; }

.gk-phase-box {
  flex: 1.4;
  background: linear-gradient(135deg, #1e1608, #150f04);
  border: 2px solid #3a3020;
  border-radius: 6px;
  padding: 0.5rem;
  text-align: center;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
}

.gk-phase-main { font-family:'Cinzel',serif; font-size:clamp(0.5rem,1.3vw,0.7rem); color:#d4b870; letter-spacing:0.12em; }
.gk-phase-hint { font-family:'Crimson Text',serif; font-size:clamp(0.7rem,1.6vw,0.9rem); color:#7a6a48; margin-top:0.25rem; font-style:italic; }

.gk-canvas-wrap { position:relative; cursor:crosshair; }
canvas#gk-c { display:block; }

.gk-controls { display:flex; gap:0.7rem; }

.gk-btn {
  font-family: 'Cinzel', serif;
  font-size: 0.62rem;
  letter-spacing: 0.12em;
  padding: 0.55rem 1.2rem;
  background: linear-gradient(135deg, #1e1608, #150f04);
  border: 2px solid #3a3020;
  border-radius: 4px;
  color: #7a6a48;
  cursor: pointer;
  transition: all 0.2s;
  text-transform: uppercase;
}
.gk-btn:hover { border-color:#6aab9a; color:#8fcfbf; box-shadow:0 0 12px rgba(106,171,154,0.2); }
.gk-btn-primary { border-color:#d4b870; color:#d4b870; }
.gk-btn-primary:hover { border-color:#f0d890; color:#f0d890; box-shadow:0 0 12px rgba(212,184,112,0.3); }

.gk-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.85); z-index:100; align-items:center; justify-content:center; backdrop-filter:blur(6px); }
.gk-overlay.show { display:flex; }

.gk-win-card {
  background: linear-gradient(145deg, #2a1e08, #1a1004);
  border: 2px solid #d4b870;
  border-radius: 12px;
  padding: 2.5rem 3.5rem;
  text-align: center;
  box-shadow: 0 0 60px rgba(212,184,112,0.25), 0 30px 60px rgba(0,0,0,0.8);
  animation: gk-pop 0.4s cubic-bezier(0.175,0.885,0.32,1.275);
}
@keyframes gk-pop { from{transform:scale(0.7) translateY(20px);opacity:0} to{transform:scale(1);opacity:1} }
.gk-win-title { font-family:'Cinzel',serif; font-size:clamp(1.4rem,5vw,2.4rem); color:#d4b870; text-shadow:0 0 30px rgba(212,184,112,0.5); margin-bottom:0.5rem; letter-spacing:0.2em; }
.gk-win-sub { font-family:'Crimson Text',serif; font-size:clamp(0.9rem,2vw,1.2rem); color:#c0b090; font-style:italic; margin-bottom:2rem; }

/* â”€â”€ Transition animations â”€â”€ */
.screen { animation: none; }
.screen.entering { animation: fade-in 0.35s ease forwards; }
@keyframes fade-in { from{opacity:0; transform:translateY(12px)} to{opacity:1; transform:translateY(0)} }
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MENU SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-menu" class="screen active">
  <div class="menu-inner">
    <div class="menu-title-wrap">
      <h1 class="menu-title">SANTORINI</h1>
      <div class="menu-title-rule"></div>
      <p class="menu-subtitle">Choose your edition</p>
    </div>

    <div class="menu-cards">
      <div class="mode-card" onclick="startGame('marble')">
        <span class="card-icon">ğŸ›ï¸</span>
        <div class="card-title">MARBLE EDITION</div>
        <div class="card-tag">CLASSIC</div>
        <p class="card-desc">An elegant top-down view rendered with stone and marble CSS styling. Clean, refined, and timeless.</p>
        <span class="card-cta">â–¸ Play Classic</span>
      </div>

      <div class="mode-card" onclick="startGame('iso')">
        <span class="card-icon">ğŸ®</span>
        <div class="card-title">PIXEL EDITION</div>
        <div class="card-tag">16-BIT ISO</div>
        <p class="card-desc">An isometric canvas-rendered world with hand-drawn pixel art buildings, workers, and domes.</p>
        <span class="card-cta">â–¸ Play Pixel</span>
      </div>

      <div class="mode-card" onclick="startGame('greek')" style="border-color:#4a7c6e;">
        <span class="card-icon">âš±ï¸</span>
        <div class="card-title">GREEK EDITION</div>
        <div class="card-tag" style="border-color:#6aab9a;color:#6aab9a;">32-BIT ISO</div>
        <p class="card-desc">Rich isometric Greek villas with marble columns, stone walls, and brilliant blue rooftops. Workers are classical marble statues of ancient builders.</p>
        <span class="card-cta" style="color:#6aab9a;">â–¸ Play Greek</span>
      </div>
    </div>

    <div class="menu-rules">
      <div class="rules-heading">âš– How to Play</div>
      <p><strong>Setup:</strong> Each player places 2 workers anywhere on the 5Ã—5 board.</p>
      <p><strong>Turn:</strong> Move one worker to an adjacent space (including diagonals), then build a level on any adjacent space.</p>
      <p><strong>Winning:</strong> Move a worker onto a <strong>Level 3 tower</strong>. You may only climb 1 level per move.</p>
      <p><strong>Blocked:</strong> If you cannot move any worker on your turn, you lose.</p>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MARBLE GAME SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-marble" class="screen">
  <div class="m-header">
    <h1>SANTORINI</h1>
    <button class="m-back-btn" onclick="goMenu('marble')">â† Back to Menu</button>
  </div>

  <div class="m-game">
    <div class="m-status-bar">
      <div class="m-player-panel" id="m-panel-p1">
        <div class="m-player-name">PLAYER I</div>
        <div class="m-worker-dots">
          <div class="m-dot p1c" id="m-dot-p1-0"></div>
          <div class="m-dot p1c" id="m-dot-p1-1"></div>
        </div>
      </div>
      <div class="m-phase-display">
        <div class="m-phase-text" id="m-phase-text">PLACE WORKERS</div>
        <div class="m-phase-sub" id="m-phase-sub">Player I places first</div>
      </div>
      <div class="m-player-panel" id="m-panel-p2">
        <div class="m-player-name">PLAYER II</div>
        <div class="m-worker-dots">
          <div class="m-dot p2c" id="m-dot-p2-0"></div>
          <div class="m-dot p2c" id="m-dot-p2-1"></div>
        </div>
      </div>
    </div>

    <div class="m-board-wrapper">
      <div class="m-board-shadow"></div>
      <div class="m-board" id="m-board"></div>
    </div>

    <div class="m-controls">
      <button class="m-btn m-btn-primary" onclick="mNewGame()">NEW GAME</button>
      <button class="m-btn" id="m-btn-cancel" onclick="mCancelSel()" style="display:none">CANCEL</button>
    </div>
  </div>
</div>

<div class="m-overlay" id="m-win-overlay">
  <div class="m-win-card">
    <div class="m-win-title" id="m-win-title">VICTORY</div>
    <div class="m-win-sub" id="m-win-sub">Player I ascended!</div>
    <button class="m-btn m-btn-primary" style="margin-top:1rem" onclick="mNewGame()">PLAY AGAIN</button>
    <br>
    <button class="m-btn" style="margin-top:0.6rem" onclick="goMenu('marble')">BACK TO MENU</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     ISO GAME SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-iso" class="screen">
  <div class="iso-header">
    <h1>SANTORINI</h1>
    <button class="iso-back-btn" onclick="goMenu('iso')">â—‚ BACK TO MENU</button>
  </div>

  <div class="iso-wrap">
    <div class="iso-status-bar">
      <div class="iso-player-panel" id="iso-panel-p1">
        <div class="iso-player-label">PLAYER I</div>
        <div class="iso-pips">
          <div class="iso-pip p1c" id="iso-pip-p1-0"></div>
          <div class="iso-pip p1c" id="iso-pip-p1-1"></div>
        </div>
      </div>
      <div class="iso-phase-box">
        <div class="iso-phase-main" id="iso-phase-main">PLACE WORKERS</div>
        <div class="iso-phase-hint" id="iso-phase-hint">Player I â€” click a tile</div>
      </div>
      <div class="iso-player-panel" id="iso-panel-p2">
        <div class="iso-player-label">PLAYER II</div>
        <div class="iso-pips">
          <div class="iso-pip p2c" id="iso-pip-p2-0"></div>
          <div class="iso-pip p2c" id="iso-pip-p2-1"></div>
        </div>
      </div>
    </div>

    <div class="iso-canvas-wrap">
      <canvas id="iso-c"></canvas>
    </div>

    <div class="iso-controls">
      <button class="iso-btn iso-btn-primary" onclick="isoNewGame()">NEW GAME</button>
      <button class="iso-btn" id="iso-btn-cancel" onclick="isoCancelSel()" style="display:none">CANCEL</button>
    </div>

    <div class="iso-legend">
      <span><span class="iso-ldot" style="background:#c8b464"></span>GROUND</span>
      <span><span class="iso-ldot" style="background:#e0d0b0"></span>LV1</span>
      <span><span class="iso-ldot" style="background:#f0ece0"></span>LV2</span>
      <span><span class="iso-ldot" style="background:#ffffff"></span>LV3</span>
      <span><span class="iso-ldot" style="background:#4080d8"></span>DOME</span>
      <span><span class="iso-ldot" style="background:#e84040"></span>P1</span>
      <span><span class="iso-ldot" style="background:#4080e8"></span>P2</span>
    </div>
  </div>
</div>

<div class="iso-overlay" id="iso-win-overlay">
  <div class="iso-win-box">
    <div class="iso-win-title" id="iso-win-title">VICTORY!</div>
    <div class="iso-win-sub" id="iso-win-sub">Player I ascends!</div>
    <button class="iso-btn iso-btn-primary" onclick="isoNewGame()">PLAY AGAIN</button>
    <br>
    <button class="iso-btn" style="margin-top:0.5rem" onclick="goMenu('iso')">BACK TO MENU</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     GREEK 32-BIT GAME SCREEN
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-greek" class="screen">
  <div class="gk-header">
    <h1>SANTORINI</h1>
    <button class="gk-back-btn" onclick="goMenu('greek')">â† Back to Menu</button>
  </div>
  <div class="gk-wrap">
    <div class="gk-status-bar">
      <div class="gk-player-panel" id="gk-panel-p1">
        <div class="gk-player-label">PLAYER I</div>
        <div class="gk-pips">
          <div class="gk-pip p1c" id="gk-pip-p1-0"></div>
          <div class="gk-pip p1c" id="gk-pip-p1-1"></div>
        </div>
      </div>
      <div class="gk-phase-box">
        <div class="gk-phase-main" id="gk-phase-main">PLACE WORKERS</div>
        <div class="gk-phase-hint" id="gk-phase-hint">Player I â€” click a tile</div>
      </div>
      <div class="gk-player-panel" id="gk-panel-p2">
        <div class="gk-player-label">PLAYER II</div>
        <div class="gk-pips">
          <div class="gk-pip p2c" id="gk-pip-p2-0"></div>
          <div class="gk-pip p2c" id="gk-pip-p2-1"></div>
        </div>
      </div>
    </div>
    <div class="gk-canvas-wrap">
      <canvas id="gk-c"></canvas>
    </div>
    <div class="gk-controls">
      <button class="gk-btn gk-btn-primary" onclick="gkNewGame()">NEW GAME</button>
      <button class="gk-btn" id="gk-btn-cancel" onclick="gkCancelSel()" style="display:none">CANCEL</button>
    </div>
  </div>
</div>

<div class="gk-overlay" id="gk-win-overlay">
  <div class="gk-win-card">
    <div class="gk-win-title" id="gk-win-title">VICTORY</div>
    <div class="gk-win-sub" id="gk-win-sub">Player I has ascended!</div>
    <button class="gk-btn gk-btn-primary" style="margin-top:1rem" onclick="gkNewGame()">PLAY AGAIN</button>
    <br>
    <button class="gk-btn" style="margin-top:0.6rem" onclick="goMenu('greek')">BACK TO MENU</button>
  </div>
</div>

<script>
'use strict';
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SCREEN MANAGER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let isoAnimFrame = null;

function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => {
    s.classList.remove('active', 'entering');
  });
  const el = document.getElementById('screen-' + id);
  el.classList.add('active');
  // Trigger reflow for animation
  void el.offsetWidth;
  el.classList.add('entering');
}

function startGame(mode) {
  if (mode === 'marble') {
    showScreen('marble');
    mNewGame();
  } else if (mode === 'iso') {
    showScreen('iso');
    isoInit();
    isoNewGame();
  } else if (mode === 'greek') {
    showScreen('greek');
    gkInit();
    gkNewGame();
  }
}

function goMenu(from) {
  if (from === 'marble') {
    document.getElementById('m-win-overlay').classList.remove('show');
  } else if (from === 'iso') {
    document.getElementById('iso-win-overlay').classList.remove('show');
    if (isoAnimFrame) { cancelAnimationFrame(isoAnimFrame); isoAnimFrame = null; }
  } else if (from === 'greek') {
    document.getElementById('gk-win-overlay').classList.remove('show');
    if (gkAnimFrame) { cancelAnimationFrame(gkAnimFrame); gkAnimFrame = null; }
  }
  showScreen('menu');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SHARED GAME LOGIC FACTORY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const GRID = 5;

function makeState() {
  return {
    board: Array.from({ length: GRID }, () =>
      Array.from({ length: GRID }, () => ({ level: 0, dome: false, worker: null }))
    ),
    workers: { p1: [null, null], p2: [null, null] },
    phase: 'place',
    currentPlayer: 'p1',
    placedCount: { p1: 0, p2: 0 },
    selectedWorker: null,
    highlightCells: [],
  };
}

function getNeighbors(r, c) {
  const res = [];
  for (let dr = -1; dr <= 1; dr++)
    for (let dc = -1; dc <= 1; dc++) {
      if (!dr && !dc) continue;
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < GRID && nc >= 0 && nc < GRID) res.push([nr, nc]);
    }
  return res;
}

function getValidMoves(S, player, idx) {
  const w = S.workers[player][idx];
  if (!w) return [];
  const from = S.board[w.r][w.c].level;
  return getNeighbors(w.r, w.c).filter(([nr, nc]) => {
    const c = S.board[nr][nc];
    return !c.dome && !c.worker && c.level <= from + 1;
  });
}

function getValidBuilds(S, r, c) {
  return getNeighbors(r, c).filter(([nr, nc]) => {
    const c2 = S.board[nr][nc];
    return !c2.dome && !c2.worker;
  });
}

function canMove(S, player) {
  return S.workers[player].some((_, i) => getValidMoves(S, player, i).length > 0);
}

function opp(p) { return p === 'p1' ? 'p2' : 'p1'; }

// Shared placement logic â€” returns updated state
function handlePlace(S, r, c) {
  const cell = S.board[r][c];
  if (cell.worker || cell.dome) return false;
  const p = S.currentPlayer;
  const idx = S.placedCount[p];
  cell.worker = { player: p, idx };
  S.workers[p][idx] = { r, c };
  S.placedCount[p]++;
  const total = S.placedCount.p1 + S.placedCount.p2;
  if (total === 1) S.currentPlayer = 'p2';
  else if (total === 2) S.currentPlayer = 'p2';
  else if (total === 3) S.currentPlayer = 'p1';
  else { S.phase = 'select'; S.currentPlayer = 'p1'; S.highlightCells = []; }
  return true;
}

// Returns 'win', 'continue', or false
function handleSelect(S, r, c) {
  const p = S.currentPlayer;
  const idx = S.workers[p].findIndex(w => w && w.r === r && w.c === c);
  if (idx === -1) return false;
  const moves = getValidMoves(S, p, idx);
  if (!moves.length) return false;
  S.selectedWorker = idx;
  S.phase = 'move';
  S.highlightCells = moves.map(([mr, mc]) => ({ r: mr, c: mc, type: 'move' }));
  return 'continue';
}

function handleMove(S, r, c) {
  const isHL = S.highlightCells.find(h => h.r === r && h.c === c);
  if (!isHL) {
    // Maybe switch worker
    const p = S.currentPlayer;
    const idx = S.workers[p].findIndex(w => w && w.r === r && w.c === c);
    if (idx !== -1 && idx !== S.selectedWorker) {
      const moves = getValidMoves(S, p, idx);
      if (!moves.length) return false;
      S.selectedWorker = idx;
      S.highlightCells = moves.map(([mr, mc]) => ({ r: mr, c: mc, type: 'move' }));
      return 'continue';
    }
    return false;
  }
  const p = S.currentPlayer;
  const idx = S.selectedWorker;
  const old = S.workers[p][idx];
  S.board[old.r][old.c].worker = null;
  S.board[r][c].worker = { player: p, idx };
  S.workers[p][idx] = { r, c };

  if (S.board[r][c].level === 3) return 'win';

  const builds = getValidBuilds(S, r, c);
  S.phase = 'build';
  S.highlightCells = builds.map(([br, bc]) => ({ r: br, c: bc, type: 'build' }));
  return 'continue';
}

function handleBuild(S, r, c) {
  const isHL = S.highlightCells.find(h => h.r === r && h.c === c);
  if (!isHL) return false;
  const cell = S.board[r][c];
  if (cell.level < 3) cell.level++;
  else cell.dome = true;

  const next = opp(S.currentPlayer);
  if (!canMove(S, next)) return 'win';

  S.currentPlayer = next;
  S.selectedWorker = null;
  S.phase = 'select';
  S.highlightCells = [];
  return 'continue';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MARBLE GAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let MS = makeState();

function mNewGame() {
  document.getElementById('m-win-overlay').classList.remove('show');
  MS = makeState();
  mRender();
}

function mCancelSel() {
  if (MS.phase === 'move') {
    MS.phase = 'select';
    MS.selectedWorker = null;
    MS.highlightCells = [];
    mRender();
  }
}

function mOnCell(r, c) {
  let result = false;
  if (MS.phase === 'place')  result = handlePlace(MS, r, c) ? 'continue' : false;
  if (MS.phase === 'select') result = handleSelect(MS, r, c);
  if (MS.phase === 'move')   result = handleMove(MS, r, c);
  if (MS.phase === 'build')  result = handleBuild(MS, r, c);

  if (result === 'win') {
    mRender();
    setTimeout(() => mShowWin(MS.currentPlayer), 150);
    return;
  }
  if (result) mRender();
}

function mShowWin(p) {
  document.getElementById('m-win-title').textContent = 'VICTORY';
  document.getElementById('m-win-sub').textContent =
    `${p === 'p1' ? 'Player I' : 'Player II'} has ascended to glory!`;
  document.getElementById('m-win-overlay').classList.add('show');
}

function mRender() {
  const boardEl = document.getElementById('m-board');
  boardEl.innerHTML = '';

  for (let r = 0; r < GRID; r++) {
    for (let c = 0; c < GRID; c++) {
      const cell = MS.board[r][c];
      const div = document.createElement('div');
      div.className = 'm-cell';
      if (cell.level > 0) {
        div.classList.add('lv' + cell.level);
        const bg = document.createElement('div');
        bg.className = 'm-cell-bg';
        div.appendChild(bg);
      }
      if (cell.dome) {
        const dome = document.createElement('div');
        dome.className = 'm-dome-piece';
        div.appendChild(dome);
      }
      if (cell.level > 0 && !cell.dome) {
        const badge = document.createElement('div');
        badge.className = 'm-lv-badge';
        badge.textContent = cell.level;
        div.appendChild(badge);
      }
      if (cell.worker) {
        const w = document.createElement('div');
        w.className = `m-worker ${cell.worker.player === 'p1' ? 'wp1' : 'wp2'}`;
        const isSel = MS.phase !== 'place' && MS.selectedWorker !== null &&
          MS.workers[MS.currentPlayer][MS.selectedWorker]?.r === r &&
          MS.workers[MS.currentPlayer][MS.selectedWorker]?.c === c;
        if (isSel) w.classList.add('sel-w');
        w.textContent = cell.worker.idx === 0 ? 'A' : 'B';
        div.appendChild(w);
      }
      const hl = MS.highlightCells.find(h => h.r === r && h.c === c);
      if (hl) div.classList.add(hl.type === 'move' ? 'hl-move' : hl.type === 'build' ? 'hl-build' : 'hl-place');
      div.addEventListener('click', () => mOnCell(r, c));
      boardEl.appendChild(div);
    }
  }

  const p1A = MS.currentPlayer === 'p1';
  document.getElementById('m-panel-p1').className = 'm-player-panel' + (p1A ? ' active-p1' : '');
  document.getElementById('m-panel-p2').className = 'm-player-panel' + (!p1A ? ' active-p2' : '');

  ['p1','p2'].forEach(p => [0,1].forEach(i => {
    document.getElementById(`m-dot-${p}-${i}`).classList.toggle('placed', MS.workers[p][i] !== null);
  }));

  const pName = MS.currentPlayer === 'p1' ? 'Player I' : 'Player II';
  const phases = { place: ['PLACE WORKERS', `${pName} â€” click a space`], select: ['SELECT WORKER', `${pName} â€” choose a worker`], move: ['MOVE', `${pName} â€” choose a space`], build: ['BUILD', `${pName} â€” choose where to build`] };
  document.getElementById('m-phase-text').textContent = phases[MS.phase][0];
  document.getElementById('m-phase-sub').textContent = phases[MS.phase][1];
  document.getElementById('m-btn-cancel').style.display = MS.phase === 'move' ? 'inline-block' : 'none';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ISO CANVAS ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let IS = makeState();
let isoCtx, isoLogW, isoLogH;
let isoFlashT = 0;

const ISO_SCALE = 3;
const TW = 32, TH = 16, WALL_H = 12, LEVEL_H = 14, DOM_R = 9;

const PAL = {
  g0_top:   ['#d4b86a','#c8a850','#b89840'], g0_left: '#8a7030',  g0_right: '#a08838',
  l1_top:   ['#e8dcc0','#ddd0b0','#ccc098'], l1_left: '#a09070',  l1_right: '#b0a080',
  l2_top:   ['#f4f0e4','#ede8d8','#ddd8c8'], l2_left: '#b8b4a0',  l2_right: '#ccc8b0',
  l3_top:   ['#ffffff','#f8f4ec','#ece8dc'], l3_left: '#c8c8c0',  l3_right: '#dcdcd0',
  dome_hi: '#80c0ff', dome_mid: '#4080d8', dome_dk: '#1040a0', dome_shad: '#203060',
  p1_hi:'#ff8888', p1_mid:'#e84040', p1_dk:'#a01818', p1_out:'#600808',
  p2_hi:'#88aaff', p2_mid:'#4080e8', p2_dk:'#1840a8', p2_out:'#081860',
};

function tilePal(level) {
  const tops  = [PAL.g0_top,  PAL.l1_top,  PAL.l2_top,  PAL.l3_top];
  const lefts = [PAL.g0_left, PAL.l1_left, PAL.l2_left, PAL.l3_left];
  const rts   = [PAL.g0_right,PAL.l1_right,PAL.l2_right,PAL.l3_right];
  return { top: tops[level], left: lefts[level], right: rts[level] };
}

function cellElev(cell) { return cell.level * LEVEL_H; }

function toScreen(gr, gc, elev) {
  const ox = isoLogW / 2;
  const oy = 44;
  return { x: ox + (gc - gr) * TW, y: oy + (gc + gr) * TH - elev };
}

function shade(hex, amt) {
  let r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  return `rgb(${Math.max(0,Math.min(255,r+amt))},${Math.max(0,Math.min(255,g+amt))},${Math.max(0,Math.min(255,b+amt))})`;
}

function isoDrawTop(ctx, x, y, c0, c1, c2) {
  ctx.beginPath();
  ctx.moveTo(x, y); ctx.lineTo(x+TW, y+TH); ctx.lineTo(x, y+TH*2); ctx.lineTo(x-TW, y+TH);
  ctx.closePath();
  const g = ctx.createLinearGradient(x-TW, y, x+TW, y+TH*2);
  g.addColorStop(0, c0); g.addColorStop(0.5, c1); g.addColorStop(1, c2);
  ctx.fillStyle = g; ctx.fill();
  ctx.strokeStyle = c0; ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x-TW+2, y+TH); ctx.stroke();
}

function isoDrawLeft(ctx, x, y, h, col) {
  ctx.beginPath();
  ctx.moveTo(x-TW, y+TH); ctx.lineTo(x, y+TH*2); ctx.lineTo(x, y+TH*2+h); ctx.lineTo(x-TW, y+TH+h);
  ctx.closePath(); ctx.fillStyle = col; ctx.fill();
  ctx.strokeStyle = shade(col, -30); ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.moveTo(x, y+TH*2); ctx.lineTo(x, y+TH*2+h); ctx.stroke();
}

function isoDrawRight(ctx, x, y, h, col) {
  ctx.beginPath();
  ctx.moveTo(x, y+TH*2); ctx.lineTo(x+TW, y+TH); ctx.lineTo(x+TW, y+TH+h); ctx.lineTo(x, y+TH*2+h);
  ctx.closePath(); ctx.fillStyle = col; ctx.fill();
  ctx.strokeStyle = shade(col, -40); ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.moveTo(x+TW, y+TH); ctx.lineTo(x+TW, y+TH+h); ctx.stroke();
}

function isoDrawCell(ctx, gr, gc, cell, hl, isSel) {
  const topLevel = cell.dome ? 3 : cell.level;
  const topElev = cellElev({ level: topLevel });
  const { x, y } = toScreen(gr, gc, topElev);

  for (let lv = 0; lv < topLevel; lv++) {
    const p = tilePal(lv);
    const { x: lx, y: ly } = toScreen(gr, gc, cellElev({ level: lv }));
    isoDrawLeft(ctx, lx, ly, LEVEL_H, p.left);
    isoDrawRight(ctx, lx, ly, LEVEL_H, p.right);
    if (lv < topLevel - 1) {
      ctx.strokeStyle = 'rgba(0,0,0,0.22)'; ctx.lineWidth = 0.5;
      const { x: mx, y: my } = toScreen(gr, gc, cellElev({ level: lv+1 }));
      ctx.beginPath(); ctx.moveTo(mx-TW, my+TH); ctx.lineTo(mx, my+TH*2); ctx.lineTo(mx+TW, my+TH); ctx.stroke();
    }
  }

  if (!cell.dome) {
    const p = tilePal(cell.level);
    isoDrawTop(ctx, x, y, p.top[0], p.top[1], p.top[2]);
    ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+TW,y+TH); ctx.moveTo(x,y); ctx.lineTo(x-TW,y+TH); ctx.stroke();
    if (hl) {
      ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+TW,y+TH); ctx.lineTo(x,y+TH*2); ctx.lineTo(x-TW,y+TH); ctx.closePath();
      ctx.fillStyle = hl; ctx.fill();
      ctx.strokeStyle = hl.replace(/[\d.]+\)$/, '0.9)'); ctx.lineWidth = 1.5; ctx.stroke();
    }
    if (isSel) {
      ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+TW,y+TH); ctx.lineTo(x,y+TH*2); ctx.lineTo(x-TW,y+TH); ctx.closePath();
      ctx.fillStyle = 'rgba(255,255,100,0.6)'; ctx.fill();
    }
  } else {
    const t3 = tilePal(3);
    isoDrawTop(ctx, x, y, t3.top[0], t3.top[1], t3.top[2]);
    isoDrawDome(ctx, x, y);
  }

  if (cell.worker) isoDrawWorker(ctx, x, y, cell.worker.player, isSel);
}

function isoDrawDome(ctx, x, y) {
  const cx = x, cy = y + TH - DOM_R - 2;
  ctx.beginPath(); ctx.ellipse(cx, cy+DOM_R, DOM_R*1.1, DOM_R*0.55, 0, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0.22)'; ctx.fill();
  for (let dy = -DOM_R; dy <= DOM_R; dy++) {
    const hw = Math.round(Math.sqrt(DOM_R*DOM_R - dy*dy) * 0.9);
    if (hw <= 0) continue;
    const t = (dy+DOM_R)/(DOM_R*2);
    const g = ctx.createLinearGradient(cx-hw, cy+dy, cx+hw, cy+dy);
    if (t < 0.3) { g.addColorStop(0, PAL.dome_mid); g.addColorStop(0.4, PAL.dome_hi); g.addColorStop(1, PAL.dome_mid); }
    else { g.addColorStop(0, PAL.dome_dk); g.addColorStop(0.5, PAL.dome_mid); g.addColorStop(1, PAL.dome_shad); }
    ctx.fillStyle = g; ctx.fillRect(cx-hw, cy+dy, hw*2, 1);
  }
  ctx.fillStyle = '#c8e8ff';
  ctx.fillRect(cx-3, cy-DOM_R+2, 2, 1); ctx.fillRect(cx-2, cy-DOM_R+3, 3, 1); ctx.fillRect(cx-1, cy-DOM_R+4, 2, 1);
}

function isoDrawWorker(ctx, x, y, player, selected) {
  const p = player === 'p1'
    ? { hi:PAL.p1_hi, mid:PAL.p1_mid, dk:PAL.p1_dk, out:PAL.p1_out }
    : { hi:PAL.p2_hi, mid:PAL.p2_mid, dk:PAL.p2_dk, out:PAL.p2_out };
  const wx = Math.round(x), wy = Math.round(y + TH - 18);
  if (selected) {
    ctx.strokeStyle = '#ffff40'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.ellipse(wx, wy+10, 10, 5, 0, 0, Math.PI*2); ctx.stroke();
  }
  ctx.fillStyle = 'rgba(0,0,0,0.28)';
  ctx.beginPath(); ctx.ellipse(wx, wy+11, 7, 3, 0, 0, Math.PI*2); ctx.fill();
  const bx = wx-4, by = wy+1;
  ctx.fillStyle = p.out; ctx.fillRect(bx-1, by-1, 10, 10);
  ctx.fillStyle = p.mid; ctx.fillRect(bx, by, 8, 8);
  ctx.fillStyle = p.hi;  ctx.fillRect(bx, by, 3, 6);
  ctx.fillStyle = p.dk;  ctx.fillRect(bx+5, by+1, 3, 7);
  ctx.fillStyle = '#f0c898'; ctx.fillRect(wx-3, wy-5, 6, 5);
  ctx.strokeStyle = '#8a6040'; ctx.lineWidth = 0.5; ctx.strokeRect(wx-3, wy-5, 6, 5);
  ctx.fillStyle = p.dk;
  ctx.fillRect(wx-3, wy-6, 6, 2); ctx.fillRect(wx-4, wy-5, 1, 3); ctx.fillRect(wx+3, wy-5, 1, 3);
  ctx.fillStyle = '#202020'; ctx.fillRect(wx-2, wy-4, 1, 1); ctx.fillRect(wx+1, wy-4, 1, 1);
  ctx.fillStyle = '#ffffff'; ctx.fillRect(wx-2, wy-4, 1, 1);
  ctx.fillStyle = '#ffffff'; ctx.font = 'bold 5px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(player === 'p1' ? '1' : '2', wx, wy+5);
}

function isoPaintOrder() {
  const order = [];
  for (let sum = 0; sum < GRID*2-1; sum++)
    for (let r = 0; r <= sum; r++) {
      const c = sum - r;
      if (r < GRID && c < GRID) order.push([r, c]);
    }
  return order;
}

function isoScreenToCell(mx, my) {
  const order = isoPaintOrder();
  for (let i = order.length-1; i >= 0; i--) {
    const [gr, gc] = order[i];
    const cell = IS.board[gr][gc];
    const elev = cellElev(cell);
    const { x, y } = toScreen(gr, gc, elev);
    const dx = mx - x, dy = my - (y + TH);
    if (Math.abs(dx/TW) + Math.abs(dy/TH) <= 1.05) return [gr, gc];
    if (elev > 0) {
      const wallTop = y + TH*2;
      if (my > wallTop && my < wallTop + elev + TH && mx > x-TW && mx < x+TW) return [gr, gc];
    }
  }
  return null;
}

function isoRenderFrame(ts) {
  isoFlashT = ts || 0;
  const ctx = isoCtx;
  ctx.clearRect(0, 0, isoLogW, isoLogH);
  const bg = ctx.createLinearGradient(0,0,0,isoLogH);
  bg.addColorStop(0,'#1a1a3a'); bg.addColorStop(1,'#0a0a18');
  ctx.fillStyle = bg; ctx.fillRect(0,0,isoLogW,isoLogH);
  ctx.fillStyle = 'rgba(0,0,0,0.055)';
  for (let sy = 0; sy < isoLogH; sy += 2) ctx.fillRect(0,sy,isoLogW,1);

  const flash = Math.sin(isoFlashT * 0.004) * 0.5 + 0.5;
  const hlMap = {};
  IS.highlightCells.forEach(({ r, c, type }) => {
    let b;
    if (type==='move')  b=[255,220,60,  0.3+flash*0.35];
    if (type==='build') b=[80, 220,100, 0.25+flash*0.3];
    if (type==='place') b=[200,140,255, 0.25+flash*0.3];
    hlMap[`${r},${c}`] = `rgba(${b[0]},${b[1]},${b[2]},${b[3]})`;
  });

  isoPaintOrder().forEach(([gr, gc]) => {
    const cell = IS.board[gr][gc];
    const hl = hlMap[`${gr},${gc}`] || null;
    let isSel = false;
    if (IS.selectedWorker !== null) {
      const w = IS.workers[IS.currentPlayer][IS.selectedWorker];
      if (w && w.r === gr && w.c === gc) isSel = true;
    }
    isoDrawCell(ctx, gr, gc, cell, hl, isSel);
  });

  isoAnimFrame = requestAnimationFrame(isoRenderFrame);
}

function isoInit() {
  if (isoAnimFrame) { cancelAnimationFrame(isoAnimFrame); isoAnimFrame = null; }
  const canvas = document.getElementById('iso-c');
  const PAD_X = 120, PAD_Y = 50;
  isoLogW = GRID * TW * 2 + PAD_X * 2;
  isoLogH = GRID * TH * 2 + PAD_Y * 2 + 100;
  canvas.width  = isoLogW * ISO_SCALE;
  canvas.height = isoLogH * ISO_SCALE;
  canvas.style.width  = isoLogW + 'px';
  canvas.style.height = isoLogH + 'px';
  isoCtx = canvas.getContext('2d');
  isoCtx.scale(ISO_SCALE, ISO_SCALE);
  isoCtx.imageSmoothingEnabled = false;

  // Attach events once
  canvas.onclick = e => {
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (isoLogW / rect.width);
    const my = (e.clientY - rect.top)  * (isoLogH / rect.height);
    const hit = isoScreenToCell(mx, my);
    if (hit) isoOnCell(hit[0], hit[1]);
  };

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const mx = (t.clientX - rect.left) * (isoLogW / rect.width);
    const my = (t.clientY - rect.top)  * (isoLogH / rect.height);
    const hit = isoScreenToCell(mx, my);
    if (hit) isoOnCell(hit[0], hit[1]);
  }, { passive: false });

  isoAnimFrame = requestAnimationFrame(isoRenderFrame);
}

function isoNewGame() {
  document.getElementById('iso-win-overlay').classList.remove('show');
  IS = makeState();
  isoUpdateUI();
}

function isoCancelSel() {
  if (IS.phase === 'move') {
    IS.phase = 'select'; IS.selectedWorker = null; IS.highlightCells = [];
    isoUpdateUI();
  }
}

function isoOnCell(r, c) {
  let result = false;
  if (IS.phase === 'place')  result = handlePlace(IS, r, c) ? 'continue' : false;
  if (IS.phase === 'select') result = handleSelect(IS, r, c);
  if (IS.phase === 'move')   result = handleMove(IS, r, c);
  if (IS.phase === 'build')  result = handleBuild(IS, r, c);

  if (result === 'win') {
    isoUpdateUI();
    setTimeout(() => isoShowWin(IS.currentPlayer), 200);
    return;
  }
  if (result) isoUpdateUI();
}

function isoShowWin(p) {
  document.getElementById('iso-win-title').textContent = 'VICTORY!';
  document.getElementById('iso-win-sub').textContent =
    `${p === 'p1' ? 'Player I' : 'Player II'} ascends to glory!`;
  document.getElementById('iso-win-overlay').classList.add('show');
}

function isoUpdateUI() {
  const p1A = IS.currentPlayer === 'p1';
  document.getElementById('iso-panel-p1').className = 'iso-player-panel' + (p1A ? ' active-p1' : '');
  document.getElementById('iso-panel-p2').className = 'iso-player-panel' + (!p1A ? ' active-p2' : '');
  ['p1','p2'].forEach(p => [0,1].forEach(i => {
    document.getElementById(`iso-pip-${p}-${i}`).classList.toggle('filled', IS.workers[p][i] !== null);
  }));
  const pName = IS.currentPlayer === 'p1' ? 'Player I' : 'Player II';
  const phases = {
    place:  ['PLACE WORKERS', `${pName} â€” click a tile`],
    select: ['SELECT WORKER', `${pName} â€” pick a worker`],
    move:   ['MOVE',          `${pName} â€” move to highlighted tile`],
    build:  ['BUILD',         `${pName} â€” choose where to build`],
  };
  document.getElementById('iso-phase-main').textContent = phases[IS.phase][0];
  document.getElementById('iso-phase-hint').textContent = phases[IS.phase][1];
  document.getElementById('iso-btn-cancel').style.display = IS.phase === 'move' ? 'inline-block' : 'none';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GREEK 32-BIT ISOMETRIC ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let GS = makeState();
let gkCtx, gkLogW, gkLogH;
let gkAnimFrame = null;
let gkFlashT = 0;

// Geometry â€” larger tiles for richer art
const GK_TW = 56;   // half-tile width
const GK_TH = 28;   // half-tile height
const GK_LEVEL_H = 22; // height per building level
const GRID5 = 5;

function gkCellElev(cell) { return cell.level * GK_LEVEL_H; }

function gkToScreen(gr, gc, elev) {
  const ox = gkLogW / 2;
  const oy = 60;
  return { x: ox + (gc - gr) * GK_TW, y: oy + (gc + gr) * GK_TH - elev };
}

function gkPaintOrder() {
  const order = [];
  for (let sum = 0; sum < GRID5*2-1; sum++)
    for (let r = 0; r <= sum; r++) {
      const c = sum - r;
      if (r < GRID5 && c < GRID5) order.push([r, c]);
    }
  return order;
}

function gkScreenToCell(mx, my) {
  const order = gkPaintOrder();
  for (let i = order.length-1; i >= 0; i--) {
    const [gr, gc] = order[i];
    const cell = GS.board[gr][gc];
    const elev = gkCellElev(cell);
    const { x, y } = gkToScreen(gr, gc, elev);
    const dx = mx - x, dy = my - (y + GK_TH);
    if (Math.abs(dx/GK_TW) + Math.abs(dy/GK_TH) <= 1.08) return [gr, gc];
    if (elev > 0) {
      const wallTop = y + GK_TH*2;
      if (my > wallTop && my < wallTop + elev + GK_TH && mx > x-GK_TW && mx < x+GK_TW) return [gr, gc];
    }
  }
  return null;
}

// â”€â”€ Colour palette (Mediterranean / Greek) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GKC = {
  // Ground tile â€” warm sandy limestone
  gnd_top_hi:  '#e8d8a8', gnd_top_mid: '#d4c090', gnd_top_lo: '#b8a870',
  gnd_left:    '#8a7848', gnd_right:   '#a08c58',
  gnd_detail:  '#c8b478',

  // Level 1 â€” rough stone walls
  l1_top_hi: '#ddd0b0', l1_top_mid: '#ccc098', l1_top_lo: '#b8ae88',
  l1_left:   '#907860', l1_right:   '#a08870',
  l1_col_hi: '#e8e0d0', l1_col_sh:  '#c0b8a0',

  // Level 2 â€” finer dressed marble
  l2_top_hi: '#f0ece0', l2_top_mid: '#e0d8c8', l2_top_lo: '#ccc8b8',
  l2_left:   '#b0a888', l2_right:   '#c0b898',
  l2_col_hi: '#f8f4ec', l2_col_sh:  '#d8d0c0',

  // Level 3 â€” white marble
  l3_top_hi: '#ffffff', l3_top_mid: '#f4f0e8', l3_top_lo: '#e4e0d8',
  l3_left:   '#c8c4b8', l3_right:   '#d8d4c8',
  l3_col_hi: '#ffffff', l3_col_sh:  '#e0dcd0',

  // Dome / Cycladic blue roof
  dome_hi:   '#a8e0f8', dome_mid:   '#5ab0e0', dome_dark: '#2068b0',
  dome_deep: '#0a3870', dome_rim:   '#3890c8',

  // Sky accent
  sky:       '#c8e8f8',

  // Player 1 statue â€” terracotta / red
  p1_marble: '#e8c0a0', p1_shadow: '#b88060', p1_dark: '#906040',
  p1_tunic:  '#c84030', p1_tsh:    '#902010', p1_trim: '#f0b040',

  // Player 2 statue â€” cool blue-grey
  p2_marble: '#c0c8d8', p2_shadow: '#8090a8', p2_dark: '#506070',
  p2_tunic:  '#2858b8', p2_tsh:    '#183888', p2_trim: '#80c0e0',

  // Highlight overlays
  hl_move:  [255, 220, 80],
  hl_build: [80,  200, 120],
  hl_place: [180, 130, 255],
};

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gkGrad(ctx, x0,y0, x1,y1, ...stops) {
  const g = ctx.createLinearGradient(x0,y0,x1,y1);
  stops.forEach(([t,c]) => g.addColorStop(t,c));
  return g;
}

function gkRadGrad(ctx, cx,cy,r0, cx2,cy2,r1, ...stops) {
  const g = ctx.createRadialGradient(cx,cy,r0,cx2,cy2,r1);
  stops.forEach(([t,c]) => g.addColorStop(t,c));
  return g;
}

function gkDiamond(ctx, x, y, tw, th) {
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x+tw, y+th);
  ctx.lineTo(x, y+th*2);
  ctx.lineTo(x-tw, y+th);
  ctx.closePath();
}

function gkLeftFace(ctx, x, y, h) {
  ctx.beginPath();
  ctx.moveTo(x-GK_TW, y+GK_TH);
  ctx.lineTo(x,       y+GK_TH*2);
  ctx.lineTo(x,       y+GK_TH*2+h);
  ctx.lineTo(x-GK_TW, y+GK_TH+h);
  ctx.closePath();
}

function gkRightFace(ctx, x, y, h) {
  ctx.beginPath();
  ctx.moveTo(x,       y+GK_TH*2);
  ctx.lineTo(x+GK_TW, y+GK_TH);
  ctx.lineTo(x+GK_TW, y+GK_TH+h);
  ctx.lineTo(x,       y+GK_TH*2+h);
  ctx.closePath();
}

// â”€â”€ Draw ground tile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gkDrawGround(ctx, x, y, hl, isSel) {
  const TW = GK_TW, TH = GK_TH;

  // Top face
  gkDiamond(ctx, x, y, TW, TH);
  ctx.fillStyle = gkGrad(ctx, x-TW,y, x+TW,y+TH*2,
    [0, GKC.gnd_top_hi], [0.5, GKC.gnd_top_mid], [1, GKC.gnd_top_lo]);
  ctx.fill();

  // Stone tile grid lines (flagstone pattern)
  ctx.save();
  ctx.clip();
  ctx.strokeStyle = 'rgba(0,0,0,0.12)';
  ctx.lineWidth = 0.8;
  // Horizontal-ish lines across the diamond
  for (let t = 0.25; t < 1; t += 0.25) {
    const yl = y + TH*2*t;
    const xl = x - TW*(1-Math.abs(t*2-1));
    const xr = x + TW*(1-Math.abs(t*2-1));
    ctx.beginPath(); ctx.moveTo(xl, yl); ctx.lineTo(xr, yl); ctx.stroke();
  }
  // Vertical-ish lines
  for (let t = 0.25; t < 1; t += 0.25) {
    ctx.beginPath();
    ctx.moveTo(x - TW + TW*2*t, y + Math.abs(t-0.5)*TH*4);
    ctx.lineTo(x - TW + TW*2*t, y + TH*2 - Math.abs(t-0.5)*TH*4);
    ctx.stroke();
  }
  // Mortar dots / texture
  ctx.fillStyle = GKC.gnd_detail;
  for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
    const px = x + dc*TW*0.4, py = y + TH + dr*TH*0.5;
    ctx.beginPath(); ctx.arc(px, py, 1.5, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();

  // Left wall
  gkLeftFace(ctx, x, y, 6);
  ctx.fillStyle = gkGrad(ctx, x-TW,y+TH, x,y+TH*2,
    [0, GKC.gnd_left], [1, '#706038']);
  ctx.fill();
  // Right wall
  gkRightFace(ctx, x, y, 6);
  ctx.fillStyle = gkGrad(ctx, x,y+TH, x+TW,y+TH*2,
    [0, GKC.gnd_right], [1, '#907848']);
  ctx.fill();

  // Top edge highlight
  ctx.strokeStyle = GKC.gnd_top_hi;
  ctx.lineWidth = 1.2;
  ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x-TW,y+TH); ctx.stroke();

  // Highlight / selection overlay
  if (hl || isSel) {
    gkDiamond(ctx, x, y, TW, TH);
    ctx.fillStyle = hl || 'rgba(255,255,100,0.5)';
    ctx.fill();
    ctx.strokeStyle = (hl||'rgba(255,255,100,0.9)').replace(/[\d.]+\)$/,'0.85)');
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

// â”€â”€ Draw a building level's wall faces â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€ Draw a building level's wall faces â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gkDrawWalls(ctx, x, y, level, faceH) {
  const palLeft  = [GKC.l1_left,  GKC.l2_left,  GKC.l3_left];
  const palRight = [GKC.l1_right, GKC.l2_right, GKC.l3_right];
  const lc = palLeft[level-1]  || GKC.l3_left;
  const rc = palRight[level-1] || GKC.l3_right;
  const TW = GK_TW, TH = GK_TH;

  // â”€â”€ Left face â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  gkLeftFace(ctx, x, y, faceH);
  ctx.fillStyle = gkGrad(ctx, x-TW, y+TH, x, y+TH*2,
    [0, lc], [0.5, shadeHex(lc,-8)], [1, shadeHex(lc,-22)]);
  ctx.fill();

  ctx.save(); ctx.clip();
  // Stone courses
  ctx.strokeStyle = 'rgba(0,0,0,0.14)'; ctx.lineWidth = 0.8;
  for (let i = 1; i <= 2; i++) {
    const t = i / 3;
    ctx.beginPath();
    ctx.moveTo(x-TW, y+TH + faceH*t + TH*(1-t));
    ctx.lineTo(x,    y+TH*2 + faceH*t);
    ctx.stroke();
  }
  // Arched window on left face (levels 2+)
  if (level >= 2) {
    const wCx = x - TW*0.52, wCy = y + TH*1.6 + faceH*0.45;
    const wW = TW*0.18, wH = faceH*0.32;
    ctx.fillStyle = shadeHex(lc, -40);
    ctx.beginPath();
    ctx.arc(wCx, wCy - wH*0.3, wW*0.5, Math.PI, 0, false);
    ctx.rect(wCx - wW*0.5, wCy - wH*0.3, wW, wH*0.55);
    ctx.fill();
    // Arch keystone
    ctx.fillStyle = shadeHex(lc, 15);
    ctx.fillRect(wCx - 1.5, wCy - wH*0.3 - wW*0.5, 3, 3);
  }
  ctx.restore();

  // Left ambient-occlusion inner edge
  ctx.strokeStyle = shadeHex(lc, 22); ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x-TW, y+TH); ctx.lineTo(x-TW, y+TH+faceH);
  ctx.stroke();

  // â”€â”€ Right face â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  gkRightFace(ctx, x, y, faceH);
  ctx.fillStyle = gkGrad(ctx, x, y+TH, x+TW, y+TH*2,
    [0, shadeHex(rc,14)], [0.5, rc], [1, shadeHex(rc,-18)]);
  ctx.fill();

  ctx.save(); ctx.clip();
  ctx.strokeStyle = 'rgba(0,0,0,0.10)'; ctx.lineWidth = 0.8;
  for (let i = 1; i <= 2; i++) {
    const t = i / 3;
    ctx.beginPath();
    ctx.moveTo(x,    y+TH*2 + faceH*t);
    ctx.lineTo(x+TW, y+TH   + faceH*t - TH*(1-t));
    ctx.stroke();
  }
  // Arched window on right face (levels 2+)
  if (level >= 2) {
    const wCx = x + TW*0.52, wCy = y + TH*1.6 + faceH*0.45;
    const wW = TW*0.18, wH = faceH*0.32;
    ctx.fillStyle = shadeHex(rc, -42);
    ctx.beginPath();
    ctx.arc(wCx, wCy - wH*0.3, wW*0.5, Math.PI, 0, false);
    ctx.rect(wCx - wW*0.5, wCy - wH*0.3, wW, wH*0.55);
    ctx.fill();
    ctx.fillStyle = shadeHex(rc, 18);
    ctx.fillRect(wCx - 1.5, wCy - wH*0.3 - wW*0.5, 3, 3);
  }
  ctx.restore();

  ctx.strokeStyle = shadeHex(rc, -28); ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x+TW, y+TH); ctx.lineTo(x+TW, y+TH+faceH);
  ctx.stroke();

  // â”€â”€ Top edge border â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(x-TW, y+TH); ctx.lineTo(x, y+TH*2); ctx.lineTo(x+TW, y+TH);
  ctx.stroke();

  // â”€â”€ Frieze band at very top for level 3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (level === 3) {
    const fH = 5;
    gkLeftFace(ctx, x, y, fH);
    ctx.fillStyle = gkGrad(ctx, x-TW,y+TH, x,y+TH*2, [0,'#e4dcc8'],[1,'#d0c8b4']);
    ctx.fill();
    ctx.save(); ctx.clip();
    ctx.fillStyle = 'rgba(0,0,0,0.18)';
    for (let ti = 0; ti < 4; ti++) {
      ctx.fillRect(x - TW*0.85 + ti*TW*0.22, y+TH+1, TW*0.07, fH-2);
    }
    ctx.restore();

    gkRightFace(ctx, x, y, fH);
    ctx.fillStyle = gkGrad(ctx, x,y+TH, x+TW,y+TH*2, [0,'#eee6d0'],[1,'#d8d0bc']);
    ctx.fill();
    ctx.save(); ctx.clip();
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    for (let ti = 0; ti < 4; ti++) {
      ctx.fillRect(x + TW*0.1 + ti*TW*0.22, y+TH+1, TW*0.07, fH-2);
    }
    ctx.restore();
  }
}

// â”€â”€ Draw columns along top edge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gkDrawColumns(ctx, x, y, level, colH) {
  const colPals = [
    [GKC.l1_col_hi, GKC.l1_col_sh],
    [GKC.l2_col_hi, GKC.l2_col_sh],
    [GKC.l3_col_hi, GKC.l3_col_sh],
  ];
  const [colHi, colSh] = colPals[level-1] || colPals[2];
  const TW = GK_TW, TH = GK_TH;
  const colW = 5;
  const colCount = 3;
  const colSpacing = TW * 0.5;

  // Draw 3 columns along left-front edge and right-front edge
  for (let side = 0; side < 2; side++) {
    for (let i = 0; i < colCount; i++) {
      const t = i / (colCount-1);
      let cx, cy;
      if (side === 0) { // left face direction
        cx = x - TW * t * 0.85;
        cy = y + TH * (1 + t * 0.85);
      } else { // right face direction
        cx = x + TW * t * 0.85;
        cy = y + TH * (1 + t * 0.85);
      }

      // Column shaft
      const g = ctx.createLinearGradient(cx-colW/2, cy, cx+colW/2, cy);
      g.addColorStop(0,   colSh);
      g.addColorStop(0.3, colHi);
      g.addColorStop(0.7, colHi);
      g.addColorStop(1,   colSh);
      ctx.fillStyle = g;
      ctx.fillRect(cx-colW/2, cy-colH, colW, colH);

      // Capital (top of column)
      ctx.fillStyle = colHi;
      ctx.fillRect(cx-colW/2-1.5, cy-colH, colW+3, 3);
      // Base
      ctx.fillStyle = colSh;
      ctx.fillRect(cx-colW/2-1, cy-2, colW+2, 2);

      // Fluting lines
      ctx.strokeStyle = colSh;
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(cx-1, cy-colH+3); ctx.lineTo(cx-1, cy-3);
      ctx.moveTo(cx+1, cy-colH+3); ctx.lineTo(cx+1, cy-3);
      ctx.stroke();
    }
  }
}

// â”€â”€ Draw top face of a building level â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gkDrawTopFace(ctx, x, y, level) {
  const TW = GK_TW, TH = GK_TH;
  const topCols = [
    [GKC.l1_top_hi, GKC.l1_top_mid, GKC.l1_top_lo],
    [GKC.l2_top_hi, GKC.l2_top_mid, GKC.l2_top_lo],
    [GKC.l3_top_hi, GKC.l3_top_mid, GKC.l3_top_lo],
  ];
  const [hi, mid, lo] = topCols[level-1] || topCols[2];

  gkDiamond(ctx, x, y, TW, TH);
  ctx.fillStyle = gkGrad(ctx, x-TW,y, x+TW,y+TH*2,
    [0, hi], [0.45, mid], [1, lo]);
  ctx.fill();

  // Courtyard detail: inner platform raised
  if (level >= 2) {
    const inset = TW*0.28;
    ctx.save(); ctx.clip();
    gkDiamond(ctx, x, y+TH*0.25, TW-inset, TH-inset*0.5);
    ctx.fillStyle = gkGrad(ctx, x,y+TH*0.25, x,y+TH*1.5,
      [0, hi], [1, shadeHex(mid,-8)]);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 0.8; ctx.stroke();
    ctx.restore();
  }

  // Edge highlight
  ctx.strokeStyle = hi; ctx.lineWidth = 1.2;
  ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x-TW,y+TH); ctx.stroke();
  ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 0.8;
  ctx.beginPath();
  ctx.moveTo(x,y); ctx.lineTo(x+TW,y+TH);
  ctx.moveTo(x,y); ctx.lineTo(x-TW,y+TH);
  ctx.stroke();
}

// â”€â”€ Draw Cycladic dome (blue rooftop) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gkDrawDome(ctx, x, y) {
  const TW = GK_TW, TH = GK_TH;
  // Dome sits centered on the top-face diamond.
  // Top-face center is at (x, y+TH). Dome rises upward from there.
  const cx = x;
  const baseY = y + TH; // where dome base meets the tile
  const rx = TW * 0.58;
  const ry = TH * 2.2;  // tall enough to look like a proper rooftop

  // Cast shadow on tile top
  gkDiamond(ctx, x, y, TW, TH);
  ctx.save(); ctx.clip();
  ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fill();
  ctx.restore();

  // Dome back rim (dark underside visible at base)
  ctx.beginPath();
  ctx.ellipse(cx, baseY, rx, TH*0.28, 0, 0, Math.PI*2);
  ctx.fillStyle = GKC.dome_deep;
  ctx.fill();

  // Main dome body â€” upper hemisphere, arching upward
  ctx.beginPath();
  ctx.ellipse(cx, baseY, rx, ry, 0, Math.PI, 0, false); // upper arc: Ï€ â†’ 0 (goes leftâ†’topâ†’right)
  ctx.lineTo(cx + rx, baseY);
  ctx.lineTo(cx - rx, baseY);
  ctx.closePath();

  const dg = ctx.createLinearGradient(cx - rx, baseY - ry, cx + rx, baseY);
  dg.addColorStop(0,   GKC.dome_hi);
  dg.addColorStop(0.25, GKC.dome_mid);
  dg.addColorStop(0.6, GKC.dome_dark);
  dg.addColorStop(1,   GKC.dome_deep);
  ctx.fillStyle = dg;
  ctx.fill();

  // Left-face shading (shadow side)
  ctx.beginPath();
  ctx.ellipse(cx, baseY, rx, ry, 0, Math.PI, Math.PI*0.5, false);
  ctx.lineTo(cx, baseY); ctx.closePath();
  ctx.fillStyle = 'rgba(0,0,30,0.22)'; ctx.fill();

  // Specular highlight â€” bright patch upper-left
  ctx.beginPath();
  ctx.ellipse(cx - rx*0.28, baseY - ry*0.62, rx*0.22, ry*0.13, -0.3, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.fill();

  // Thin secondary highlight streak
  ctx.beginPath();
  ctx.ellipse(cx - rx*0.1, baseY - ry*0.82, rx*0.08, ry*0.06, -0.2, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.fill();

  // Rim stripe at base (white terracotta band)
  ctx.beginPath();
  ctx.ellipse(cx, baseY, rx, TH*0.28, 0, 0, Math.PI*2);
  const rimG = gkGrad(ctx, cx-rx, baseY, cx+rx, baseY,
    [0,'#e8e0d0'],[0.3, GKC.dome_rim],[0.7,'#e8e0d0'],[1,'#c8c0b0']);
  ctx.fillStyle = rimG;
  ctx.fill();
  ctx.strokeStyle = '#a09880'; ctx.lineWidth = 0.8; ctx.stroke();

  // Cross / finial at apex
  const apexY = baseY - ry - 2;
  ctx.strokeStyle = '#f0ece0'; ctx.lineWidth = 2.5; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(cx, apexY); ctx.lineTo(cx, apexY - 9); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx-5, apexY-5); ctx.lineTo(cx+5, apexY-5); ctx.stroke();
  // Finial ball
  ctx.fillStyle = '#f0e8c0';
  ctx.beginPath(); ctx.arc(cx, apexY-9, 2.5, 0, Math.PI*2); ctx.fill();
}

// â”€â”€ Draw complete cell â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gkDrawCell(ctx, gr, gc, cell, hl, isSel) {
  const topLevel = cell.dome ? 3 : cell.level;
  const faceH = GK_LEVEL_H;

  // â”€â”€ Always draw the ground tile at elev=0 first â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const { x: gx, y: gy } = gkToScreen(gr, gc, 0);
  gkDrawGround(ctx, gx, gy, cell.level === 0 ? hl : null, cell.level === 0 ? isSel : false);

  if (topLevel === 0) {
    // Worker on ground
    if (cell.worker) gkDrawWorker(ctx, gx, gy, cell.worker.player, isSel && cell.worker.player === GS.currentPlayer);
    return;
  }

  // â”€â”€ Stack wall faces for each building level â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (let lv = 1; lv <= topLevel; lv++) {
    const btmElev = gkCellElev({ level: lv-1 });
    const { x: wx, y: wy } = gkToScreen(gr, gc, btmElev);
    gkDrawWalls(ctx, wx, wy, lv, faceH);
  }

  // â”€â”€ Top face of highest level â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const { x, y } = gkToScreen(gr, gc, gkCellElev({ level: topLevel }));

  if (!cell.dome) {
    gkDrawTopFace(ctx, x, y, cell.level);
    gkDrawColumns(ctx, x, y, cell.level, faceH * 0.72);
    if (hl || isSel) {
      gkDiamond(ctx, x, y, GK_TW, GK_TH);
      ctx.fillStyle = hl || 'rgba(255,255,100,0.45)';
      ctx.fill();
      ctx.strokeStyle = (hl || 'rgba(255,255,100,0.9)').replace(/[\d.]+\)$/, '0.85)');
      ctx.lineWidth = 2; ctx.stroke();
    }
  } else {
    gkDrawTopFace(ctx, x, y, 3);
    gkDrawColumns(ctx, x, y, 3, faceH * 0.72);
    gkDrawDome(ctx, x, y);
  }

  // â”€â”€ Worker stands on top surface â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (cell.worker) gkDrawWorker(ctx, x, y, cell.worker.player, isSel && cell.worker.player === GS.currentPlayer);
}

// â”€â”€ Draw Greek statue worker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gkDrawWorker(ctx, x, y, player, selected) {
  const TW = GK_TW, TH = GK_TH;
  const wx = Math.round(x);
  const wy = Math.round(y + TH - 2); // stand on top surface

  const p = player === 'p1'
    ? { skin: GKC.p1_marble, shadow: GKC.p1_shadow, dark: GKC.p1_dark, tunic: GKC.p1_tunic, tsh: GKC.p1_tsh, trim: GKC.p1_trim }
    : { skin: GKC.p2_marble, shadow: GKC.p2_shadow, dark: GKC.p2_dark, tunic: GKC.p2_tunic, tsh: GKC.p2_tsh, trim: GKC.p2_trim };

  // Selection ring
  if (selected) {
    ctx.strokeStyle = '#f0d060'; ctx.lineWidth = 2.5;
    ctx.setLineDash([4,3]);
    ctx.beginPath(); ctx.ellipse(wx, wy+6, 16, 7, 0, 0, Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);
  }

  // Drop shadow
  ctx.save();
  ctx.scale(1, 0.4);
  ctx.beginPath(); ctx.arc(wx, wy/0.4+12, 12, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fill();
  ctx.restore();

  // â”€â”€ Legs / Chiton skirt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ctx.fillStyle = p.tunic;
  // Skirt trapezoid
  ctx.beginPath();
  ctx.moveTo(wx-7, wy-8);
  ctx.lineTo(wx+7, wy-8);
  ctx.lineTo(wx+9, wy+4);
  ctx.lineTo(wx-9, wy+4);
  ctx.closePath();
  ctx.fill();
  // Skirt shading
  ctx.fillStyle = p.tsh;
  ctx.beginPath();
  ctx.moveTo(wx+3, wy-8); ctx.lineTo(wx+7, wy-8); ctx.lineTo(wx+9, wy+4); ctx.lineTo(wx+3, wy+4);
  ctx.closePath(); ctx.fill();
  // Hem trim
  ctx.fillStyle = p.trim;
  ctx.fillRect(wx-9, wy+2, 18, 2);

  // Sandal feet
  ctx.fillStyle = p.dark;
  ctx.beginPath(); ctx.ellipse(wx-5, wy+6, 5, 2.5, 0.2, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(wx+5, wy+6, 5, 2.5, -0.2, 0, Math.PI*2); ctx.fill();

  // â”€â”€ Torso â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Chiton body
  ctx.fillStyle = p.tunic;
  ctx.beginPath();
  ctx.moveTo(wx-7, wy-22);
  ctx.lineTo(wx+7, wy-22);
  ctx.lineTo(wx+8, wy-8);
  ctx.lineTo(wx-8, wy-8);
  ctx.closePath(); ctx.fill();
  // Torso shading
  ctx.fillStyle = p.tsh;
  ctx.beginPath();
  ctx.moveTo(wx+2, wy-22); ctx.lineTo(wx+7, wy-22); ctx.lineTo(wx+8, wy-8); ctx.lineTo(wx+2, wy-8);
  ctx.closePath(); ctx.fill();
  // Belt / sash
  ctx.fillStyle = p.trim;
  ctx.fillRect(wx-8, wy-11, 16, 3);

  // â”€â”€ Arms â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Left arm (holds a small scroll/tool â€” raised slightly)
  ctx.strokeStyle = p.skin; ctx.lineWidth = 5; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(wx-7, wy-20); ctx.lineTo(wx-14, wy-14); ctx.stroke();
  ctx.strokeStyle = p.shadow; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(wx-7, wy-20); ctx.lineTo(wx-14, wy-14); ctx.stroke();
  // Right arm (pointing forward/working)
  ctx.strokeStyle = p.skin; ctx.lineWidth = 5;
  ctx.beginPath(); ctx.moveTo(wx+7, wy-20); ctx.lineTo(wx+13, wy-16); ctx.stroke();
  ctx.strokeStyle = p.shadow; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(wx+7, wy-20); ctx.lineTo(wx+13, wy-16); ctx.stroke();

  // Small tool in right hand (mason's hammer)
  ctx.fillStyle = p.dark;
  ctx.fillRect(wx+12, wy-19, 6, 3);
  ctx.fillStyle = '#a08060';
  ctx.fillRect(wx+14, wy-16, 2, 5);

  // â”€â”€ Head â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Neck
  ctx.fillStyle = p.skin;
  ctx.fillRect(wx-3, wy-27, 6, 5);
  ctx.strokeStyle = p.shadow; ctx.lineWidth = 0.8;
  ctx.strokeRect(wx-3, wy-27, 6, 5);

  // Head oval
  const headGrad = gkRadGrad(ctx, wx-2,wy-33, 1, wx,wy-30, 9,
    [0, shadeHex(p.skin,20)], [0.5, p.skin], [1, p.shadow]);
  ctx.fillStyle = headGrad;
  ctx.beginPath(); ctx.ellipse(wx, wy-32, 8, 9, 0, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = p.shadow; ctx.lineWidth = 0.8;
  ctx.beginPath(); ctx.ellipse(wx, wy-32, 8, 9, 0, 0, Math.PI*2); ctx.stroke();

  // Helmet / wreath crown
  ctx.fillStyle = p.trim;
  ctx.beginPath();
  ctx.moveTo(wx-9, wy-38);
  ctx.bezierCurveTo(wx-8,wy-44, wx+8,wy-44, wx+9,wy-38);
  ctx.lineTo(wx+7, wy-39);
  ctx.bezierCurveTo(wx+6,wy-42, wx-6,wy-42, wx-7,wy-39);
  ctx.closePath();
  ctx.fill();
  // Wreath leaves
  for (let li = -1; li <= 1; li++) {
    ctx.fillStyle = '#70a040';
    ctx.beginPath();
    ctx.ellipse(wx + li*5, wy-40, 3, 1.5, li*0.5, 0, Math.PI*2);
    ctx.fill();
  }

  // Eyes
  ctx.fillStyle = '#302010';
  ctx.beginPath(); ctx.arc(wx-3, wy-33, 1.2, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(wx+3, wy-33, 1.2, 0, Math.PI*2); ctx.fill();
  // Eye whites
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.beginPath(); ctx.arc(wx-3.3, wy-33.3, 0.6, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(wx+2.7, wy-33.3, 0.6, 0, Math.PI*2); ctx.fill();

  // Nose hint
  ctx.strokeStyle = p.shadow; ctx.lineWidth = 1; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(wx, wy-32); ctx.lineTo(wx+1, wy-29); ctx.stroke();

  // Mouth (slight smile for winner, neutral otherwise)
  ctx.strokeStyle = p.dark; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.arc(wx, wy-27, 2, 0.1, Math.PI-0.1); ctx.stroke();

  // Player label badge on tunic
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath(); ctx.ellipse(wx, wy-15, 5, 4, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 7px serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(player === 'p1' ? 'I' : 'II', wx, wy-15);
}

// helper for shade
function shadeHex(hex, amt) {
  const r = Math.max(0,Math.min(255, parseInt(hex.slice(1,3),16)+amt));
  const g = Math.max(0,Math.min(255, parseInt(hex.slice(3,5),16)+amt));
  const b = Math.max(0,Math.min(255, parseInt(hex.slice(5,7),16)+amt));
  return `rgb(${r},${g},${b})`;
}

// â”€â”€ Environment: sky, sea, distant hills â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gkDrawBackground(ctx, W, H) {
  // â”€â”€ Sky gradient â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const sky = gkGrad(ctx, 0,0, 0,H*0.52,
    [0,'#3a8cc8'],[0.35,'#6ab4e0'],[0.7,'#a8d8f0'],[1,'#cce8f8']);
  ctx.fillStyle = sky; ctx.fillRect(0,0,W,H);

  // â”€â”€ Sun with rays â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const sunX = W*0.80, sunY = H*0.10;
  // Ray glow
  const sunGlow = gkRadGrad(ctx, sunX,sunY,0, sunX,sunY,80,
    [0,'rgba(255,240,160,0.7)'],[0.4,'rgba(255,210,80,0.25)'],[1,'rgba(255,180,0,0)']);
  ctx.fillStyle = sunGlow;
  ctx.beginPath(); ctx.arc(sunX,sunY,80,0,Math.PI*2); ctx.fill();
  // Sun disc
  ctx.fillStyle = '#fff8c0';
  ctx.beginPath(); ctx.arc(sunX,sunY,14,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#ffe860';
  ctx.beginPath(); ctx.arc(sunX,sunY,10,0,Math.PI*2); ctx.fill();
  // Rays
  ctx.strokeStyle = 'rgba(255,240,120,0.4)'; ctx.lineWidth = 1.5; ctx.lineCap = 'round';
  for (let a = 0; a < Math.PI*2; a += Math.PI/6) {
    ctx.beginPath();
    ctx.moveTo(sunX+Math.cos(a)*16, sunY+Math.sin(a)*16);
    ctx.lineTo(sunX+Math.cos(a)*28, sunY+Math.sin(a)*28);
    ctx.stroke();
  }

  // â”€â”€ Clouds â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function drawCloud(cx, cy, scale) {
    ctx.fillStyle = 'rgba(255,255,255,0.88)';
    const puffs = [{x:0,y:0,r:14},{x:18,y:4,r:18},{x:38,y:2,r:14},{x:54,y:6,r:12},
                   {x:12,y:-8,r:12},{x:30,y:-10,r:15},{x:48,y:-6,r:11}];
    puffs.forEach(p => {
      ctx.beginPath();
      ctx.arc(cx+p.x*scale, cy+p.y*scale, p.r*scale, 0, Math.PI*2);
      ctx.fill();
    });
    // Underside shadow
    ctx.fillStyle = 'rgba(160,190,220,0.35)';
    [{x:6,r:12},{x:22,r:16},{x:40,r:12},{x:54,r:10}].forEach(p => {
      ctx.beginPath(); ctx.arc(cx+p.x*scale, cy+9*scale, p.r*scale*0.6, 0, Math.PI*2); ctx.fill();
    });
  }
  drawCloud(W*0.05, H*0.07, 0.9);
  drawCloud(W*0.30, H*0.04, 1.1);
  drawCloud(W*0.55, H*0.09, 0.75);
  drawCloud(W*0.72, H*0.18, 0.6);

  // â”€â”€ Distant island cliffs / coastline â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const horizonY = H*0.42;

  // Far island â€” pale blue-grey
  ctx.fillStyle = '#b8c8d4';
  ctx.beginPath();
  ctx.moveTo(W*0.0, horizonY);
  ctx.bezierCurveTo(W*0.05,H*0.30, W*0.12,H*0.28, W*0.20,H*0.31);
  ctx.bezierCurveTo(W*0.27,H*0.29, W*0.30,H*0.33, W*0.34,horizonY);
  ctx.closePath(); ctx.fill();

  // Mid island â€” slightly greener
  ctx.fillStyle = '#9ab8a0';
  ctx.beginPath();
  ctx.moveTo(W*0.42, horizonY);
  ctx.bezierCurveTo(W*0.44,H*0.31, W*0.52,H*0.27, W*0.60,H*0.30);
  ctx.bezierCurveTo(W*0.68,H*0.28, W*0.74,H*0.33, W*0.78,horizonY);
  ctx.closePath(); ctx.fill();

  // White village buildings on mid island (tiny whitewashed cubes)
  ctx.fillStyle = '#f0ece0';
  for (let bx = W*0.48; bx < W*0.70; bx += W*0.025) {
    const bh = H*0.018 + Math.sin(bx*7)*H*0.008;
    const by = H*0.295 - bh;
    ctx.fillRect(bx, by, W*0.018, bh);
    // Tiny blue dome on some buildings
    if (Math.sin(bx*13) > 0.4) {
      ctx.fillStyle = '#4898c8';
      ctx.beginPath();
      ctx.arc(bx+W*0.009, by, W*0.009, Math.PI, 0, false);
      ctx.fill();
      ctx.fillStyle = '#f0ece0';
    }
  }

  // Right island / cape
  ctx.fillStyle = '#a8b8a0';
  ctx.beginPath();
  ctx.moveTo(W*0.84, horizonY);
  ctx.bezierCurveTo(W*0.86,H*0.32, W*0.93,H*0.29, W*1.0,H*0.31);
  ctx.lineTo(W,horizonY); ctx.closePath(); ctx.fill();

  // Cypress trees on left coastline
  function drawCypress(cx, cy, h) {
    ctx.fillStyle = '#2a5a30';
    ctx.beginPath();
    ctx.moveTo(cx, cy-h);
    ctx.bezierCurveTo(cx-h*0.18, cy-h*0.55, cx-h*0.14, cy-h*0.1, cx, cy);
    ctx.bezierCurveTo(cx+h*0.14, cy-h*0.1, cx+h*0.18, cy-h*0.55, cx, cy-h);
    ctx.fill();
    // Highlight streak
    ctx.fillStyle = '#3a7a42';
    ctx.beginPath();
    ctx.moveTo(cx, cy-h); ctx.lineTo(cx+h*0.05, cy-h*0.4); ctx.lineTo(cx, cy-h*0.15);
    ctx.fill();
  }
  drawCypress(W*0.08, H*0.38, H*0.065);
  drawCypress(W*0.12, H*0.395, H*0.055);
  drawCypress(W*0.155, H*0.385, H*0.06);
  drawCypress(W*0.87, H*0.38, H*0.05);
  drawCypress(W*0.91, H*0.39, H*0.06);

  // Horizon haze
  ctx.fillStyle = 'rgba(200,230,248,0.4)';
  ctx.fillRect(0, horizonY-4, W, 8);

  // â”€â”€ Sea â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const sea = gkGrad(ctx, 0,horizonY, 0,H,
    [0,'#5aacd8'],[0.2,'#3888c0'],[0.6,'#1c60a0'],[1,'#0a3870']);
  ctx.fillStyle = sea; ctx.fillRect(0, horizonY, W, H-horizonY);

  // Sea wave shimmer
  ctx.strokeStyle = 'rgba(255,255,255,0.18)'; ctx.lineWidth = 1;
  for (let sy = horizonY+6; sy < H*0.62; sy += 7) {
    const waveAmp = (sy - horizonY) * 0.015;
    ctx.beginPath(); ctx.moveTo(0, sy);
    for (let sx = 0; sx < W; sx += 16) {
      ctx.lineTo(sx+8,  sy + Math.sin(sx*0.18 + sy*0.05)*waveAmp);
      ctx.lineTo(sx+16, sy);
    }
    ctx.stroke();
  }
  // Sunlight sparkle path on water
  const sparkle = gkGrad(ctx, sunX-30, horizonY+5, sunX+30, H*0.58,
    [0,'rgba(255,240,160,0)'],[0.3,'rgba(255,240,120,0.22)'],[0.7,'rgba(255,220,80,0.12)'],[1,'rgba(255,200,0,0)']);
  ctx.fillStyle = sparkle;
  ctx.fillRect(sunX-50, horizonY, 100, H*0.2);

  // â”€â”€ Rocky ground platform the board sits on â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const groundY = H*0.50;
  // Main ground fill
  const gndG = gkGrad(ctx, 0,groundY, 0,H,
    [0,'#d4c090'],[0.15,'#c4b080'],[0.5,'#b09060'],[1,'#806840']);
  ctx.fillStyle = gndG; ctx.fillRect(0, groundY, W, H-groundY);

  // Ground texture â€” subtle horizontal rock strata
  ctx.strokeStyle = 'rgba(0,0,0,0.07)'; ctx.lineWidth = 1;
  for (let gy = groundY+6; gy < H; gy += 10) {
    ctx.beginPath(); ctx.moveTo(0, gy);
    for (let gx = 0; gx < W; gx += 30) {
      ctx.lineTo(gx+15, gy + Math.sin(gx*0.12)*1.5);
      ctx.lineTo(gx+30, gy);
    }
    ctx.stroke();
  }
  // Small pebble dots
  ctx.fillStyle = 'rgba(160,140,100,0.4)';
  for (let pi = 0; pi < 30; pi++) {
    const px = (pi * W * 0.037) % W;
    const py = groundY + 8 + (pi * 11) % 22;
    ctx.beginPath(); ctx.arc(px, py, 1.5+Math.sin(pi)*1, 0, Math.PI*2); ctx.fill();
  }

  // Ground-sea edge: thin sandy beach line
  ctx.fillStyle = '#e8d8a8';
  ctx.fillRect(0, horizonY-1, W, 5);

  // â”€â”€ Edge vignette â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const vig = ctx.createRadialGradient(W/2,H*0.5,H*0.2, W/2,H*0.5,H*0.75);
  vig.addColorStop(0,'transparent'); vig.addColorStop(1,'rgba(0,0,0,0.30)');
  ctx.fillStyle = vig; ctx.fillRect(0,0,W,H);
}

// â”€â”€ Main render loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gkRenderFrame(ts) {
  gkFlashT = ts || 0;
  const ctx = gkCtx;
  const W = gkLogW, H = gkLogH;

  ctx.clearRect(0,0,W,H);
  gkDrawBackground(ctx, W, H);

  const flash = Math.sin(gkFlashT*0.003)*0.5+0.5;
  const hlMap = {};
  GS.highlightCells.forEach(({r,c,type}) => {
    const [rc,gc,bc] = GKC['hl_'+type] || [255,220,80];
    hlMap[`${r},${c}`] = `rgba(${rc},${gc},${bc},${0.28+flash*0.28})`;
  });

  gkPaintOrder().forEach(([gr,gc]) => {
    const cell = GS.board[gr][gc];
    const hl = hlMap[`${gr},${gc}`] || null;
    let isSel = false;
    if (GS.selectedWorker !== null) {
      const w = GS.workers[GS.currentPlayer][GS.selectedWorker];
      if (w && w.r===gr && w.c===gc) isSel=true;
    }
    gkDrawCell(ctx, gr, gc, cell, hl, isSel);
  });

  gkAnimFrame = requestAnimationFrame(gkRenderFrame);
}

// â”€â”€ Init & new game â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gkInit() {
  if (gkAnimFrame) { cancelAnimationFrame(gkAnimFrame); gkAnimFrame = null; }
  const canvas = document.getElementById('gk-c');
  gkLogW = GRID5 * GK_TW * 2 + 200;
  gkLogH = GRID5 * GK_TH * 2 + 220;
  canvas.width  = gkLogW;
  canvas.height = gkLogH;
  canvas.style.width  = Math.min(gkLogW, window.innerWidth - 20) + 'px';
  canvas.style.height = 'auto';
  gkCtx = canvas.getContext('2d');
  gkCtx.imageSmoothingEnabled = true;
  gkCtx.imageSmoothingQuality = 'high';

  canvas.onclick = e => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = gkLogW / rect.width;
    const scaleY = gkLogH / rect.height;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top)  * scaleY;
    const hit = gkScreenToCell(mx, my);
    if (hit) gkOnCell(hit[0], hit[1]);
  };

  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    const t = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const mx = (t.clientX - rect.left) * (gkLogW / rect.width);
    const my = (t.clientY - rect.top)  * (gkLogH / rect.height);
    const hit = gkScreenToCell(mx, my);
    if (hit) gkOnCell(hit[0], hit[1]);
  }, { passive: false });

  gkAnimFrame = requestAnimationFrame(gkRenderFrame);
}

function gkNewGame() {
  document.getElementById('gk-win-overlay').classList.remove('show');
  GS = makeState();
  gkUpdateUI();
}

function gkCancelSel() {
  if (GS.phase === 'move') {
    GS.phase = 'select'; GS.selectedWorker = null; GS.highlightCells = [];
    gkUpdateUI();
  }
}

function gkOnCell(r, c) {
  let result = false;
  if (GS.phase === 'place')  result = handlePlace(GS, r, c) ? 'continue' : false;
  if (GS.phase === 'select') result = handleSelect(GS, r, c);
  if (GS.phase === 'move')   result = handleMove(GS, r, c);
  if (GS.phase === 'build')  result = handleBuild(GS, r, c);
  if (result === 'win') {
    gkUpdateUI();
    setTimeout(() => gkShowWin(GS.currentPlayer), 200);
    return;
  }
  if (result) gkUpdateUI();
}

function gkShowWin(p) {
  document.getElementById('gk-win-title').textContent = 'VICTORY';
  document.getElementById('gk-win-sub').textContent =
    `${p==='p1'?'Player I':'Player II'} has ascended to glory!`;
  document.getElementById('gk-win-overlay').classList.add('show');
}

function gkUpdateUI() {
  const p1A = GS.currentPlayer === 'p1';
  document.getElementById('gk-panel-p1').className = 'gk-player-panel'+(p1A?' active-p1':'');
  document.getElementById('gk-panel-p2').className = 'gk-player-panel'+(!p1A?' active-p2':'');
  ['p1','p2'].forEach(p => [0,1].forEach(i => {
    document.getElementById(`gk-pip-${p}-${i}`).classList.toggle('filled', GS.workers[p][i]!==null);
  }));
  const pName = GS.currentPlayer==='p1'?'Player I':'Player II';
  const phases = {
    place:  ['PLACE WORKERS', `${pName} â€” click a tile`],
    select: ['SELECT WORKER', `${pName} â€” choose a worker`],
    move:   ['MOVE',          `${pName} â€” move to highlighted tile`],
    build:  ['BUILD',         `${pName} â€” choose where to build`],
  };
  document.getElementById('gk-phase-main').textContent = phases[GS.phase][0];
  document.getElementById('gk-phase-hint').textContent = phases[GS.phase][1];
  document.getElementById('gk-btn-cancel').style.display = GS.phase==='move'?'inline-block':'none';
}

// â”€â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showScreen('menu');
</script>
</body>
</html>
